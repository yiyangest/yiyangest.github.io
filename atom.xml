<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>深谷</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yiyangest.github.io/"/>
  <updated>2018-02-27T10:02:03.000Z</updated>
  <id>http://yiyangest.github.io/</id>
  
  <author>
    <name>yiyangest</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yiyangest.github.io/2018/02/27/hello-world/"/>
    <id>http://yiyangest.github.io/2018/02/27/hello-world/</id>
    <published>2018-02-27T10:02:03.000Z</published>
    <updated>2018-02-27T10:02:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Review Network Error</title>
    <link href="http://yiyangest.github.io/2017/12/22/review-network-error/"/>
    <id>http://yiyangest.github.io/2017/12/22/review-network-error/</id>
    <published>2017-12-21T16:00:00.000Z</published>
    <updated>2018-02-27T10:06:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重新审视“网络连接错误”"><a href="#重新审视“网络连接错误”" class="headerlink" title="重新审视“网络连接错误”"></a>重新审视“网络连接错误”</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做项目的过程当中遇到了一件颇有启发性的事情，在此分享给大家。请注意这篇文章绝对不是干货，相反，非常的”湿”.</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>早在11月初的时候，做了很久的某直播项目终于提测了，屁颠颠的提测到QA那。过了没多久，QA同学招唤我，”YYY, 这个进直播间总是卡在80%进不去啊。提示加载失败。”</p><p>“怎么可能，我写的代码怎么会有Bug, 肯定是你网不好吧”。</p><p>为了证明我的清白(怕被自己打脸)，于是从神策上拉了日志，日志显示”信令SDK server can not connect”。松了一口气，不是我的锅。</p><p>面对铁证如山，QA同学虽然很是怀疑，但是还是放过了我。作为一名有责任心的RD，为了进一步将问题明确(甩锅)，将信令连接失败的错误作为网络错误在弹窗上显示出来。</p><p>随着测试过程的不断深入，发现了越来越多的Bug（???），进不去直播间的问题还是时有发生。于是信令同学细化了相关的日志以便排查问题。</p><p>而我们在公司自测开发的过程当中，也出现了进直播间失败的情况。当时日志显示所有的ep节点都ping失败了。</p><h2 id="进教室选点逻辑"><a href="#进教室选点逻辑" class="headerlink" title="进教室选点逻辑"></a>进教室选点逻辑</h2><p>这里先简单插入一下进直播间过程当中的选点逻辑。</p><p>服务端会返回9个（目前是9个）EP节点的IP列表(含端口)。之后信令SDK会对每个IP开启一个线程，每个线程里串行的连续对该IP进行5次ping请求。</p><p>每个ping请求实际上是访问了这个节点的一个HTTP服务。这个HTTP服务什么也没做，直接返回success给客户端。</p><p>大概是长这个样子：<code>http://ip:port/ping?xxx=yyy</code>.</p><p>目前端口都是8080。</p><p>最后哪个IP的线程先执行完，那就代表哪个IP对客户端而言最优，于是会把这个IP作为后续流程的服务器。</p><p><em>这里我们不去探究这个选点逻辑的优劣。感兴趣的同学可以自己设计一个选点策略。</em></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>现在日志很清晰的告诉你，9个ep节点，每个ep节点都ping失败，访问不通。小明，你怎么看？</p><h3 id="答案一"><a href="#答案一" class="headerlink" title="答案一"></a>答案一</h3><p>是不是当时网断了，网络情况很差。一开始我想当然的也是这么认为。</p><p>可是ep选点之前还要经过其他好多接口，其他接口访问都没事。那证明网络是好的，并没有问题。</p><h3 id="答案二"><a href="#答案二" class="headerlink" title="答案二"></a>答案二</h3><p>那会不会是服务端挂了。</p><p>一共9台服务器，都挂的概率也太低了吧，而且当时老师端是能进去的，也是同样的网络与选点策略。</p><h3 id="答案三"><a href="#答案三" class="headerlink" title="答案三"></a>答案三</h3><p>会不会是信令SDK存在什么bug，在某种情况下会导致网络请求发不出去。</p><p>嗯。你的怀疑很有道理，但是证据呢？</p><h3 id="答案四"><a href="#答案四" class="headerlink" title="答案四"></a>答案四</h3><p>会不会是iOS系统有什么连接数限制，同一时间发起这么多请求，触到了系统的禁忌之地？</p><p>嗯。想想也是相当有道理。怎么验证？</p><h3 id="答案五"><a href="#答案五" class="headerlink" title="答案五"></a>答案五</h3><p>由于ping服务是HTTP服务，且使用了一个非常规端口：8080。那有没有可能是端口被封呢？</p><p>在某些网络环境下的确有可能。不过多数情况下，在我们的公司网络下访问是没有问题的。</p><p>那总不会是当一些特定情况下会把8080端口封了，而大多数情况下又恢复了呢？可能性比较低，但也不能完全否定。</p><h2 id="找证据"><a href="#找证据" class="headerlink" title="找证据"></a>找证据</h2><p>前面答案一和答案二经不起推敲，后面两个答案初步审视感觉有点靠谱，但怎么验证呢？</p><p>答案四提到的连接数限制，印象中之前看过一篇文章提到过移动设备上的网络连接数限制。</p><p>后来一顿疯狂搜索之后得出的结论是: <em>对同一Host下的网络请求会限制并发连接数，并且这个数与iOS版本及当时的网络情况(2G/3G/WIFI)有关系</em>.</p><p>查了官方文档，虽然没有明确的这种结论，但是<code>NSURLSessionConfiguration</code>里的<code>HTTPMaximumConnectionsPerHost</code>还是可以大致推断刚才那个结论应该是正确的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Declaration</span><br><span class="line"></span><br><span class="line">@property NSInteger HTTPMaximumConnectionsPerHost;</span><br><span class="line"></span><br><span class="line">Discussion</span><br><span class="line"></span><br><span class="line">This property determines the maximum number of simultaneous connections</span><br><span class="line">made to each host by tasks within sessions based on this configuration.</span><br><span class="line"></span><br><span class="line">This limit is per session, so if you use multiple sessions,</span><br><span class="line">your app as a whole may exceed this limit.</span><br><span class="line">Additionally, depending on your connection to the Internet,</span><br><span class="line">a session may use a lower limit than the one you specify.</span><br><span class="line"></span><br><span class="line">The default value is 6 in macOS, or 4 in iOS.</span><br></pre></td></tr></table></figure><p>可是细想之下，9个EP节点，每个的HOST都是不同的啊，并不符合这里提到的同一host的连接数限制。难道不同的host也会有一个最大连接数的潜规则吗？</p><p>案件到这里感觉得不到更多有价值的线索了。难道又要成为一桩悬案了吗？</p><p>再怎么如何在网上去搜索你想要的答案，不如自己动手来验证一下。</p><p>既然涉及网络，那就抓包吧。这里不详细介绍如何抓包，大家感兴趣可以看以下几篇文章：</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/23377655?refer=mrpeak" target="_blank" rel="noopener">iOS,Android网络抓包教程之tcpdump</a></p></li><li><p><a href="http://www.jianshu.com/p/bcf6d15ee950" target="_blank" rel="noopener">iOS抓包工具之tcpdump</a></p></li></ul><p>P.S. 信令SDK用C++编写，采用curl去做网络请求，用charles抓不到，有知道内情的同学可以分享一下～</p><p>在疯狂进出教室几百次之后，终于让我很幸运的复现了一次进教室失败。于是用颤抖的双手点开了Wireshark，来见一见这位谜一样的女子揭下神秘面纱后的样子吧：</p><p><img src="tcpdump.jpeg" alt="TCP dump"></p><p>WTF??&amp;#$&amp;#&amp;?喵了个咪？这些都是什么鬼？打码了吗？？</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>同学们，请翻到教材“计算机网络”的第xx页，这是重点，要考的哦。</p><p>“啪叽”,一个板擦砸中了我骄傲的后脑勺。”YYY，快下课了你还睡！”。</p><p>好了，同学们，让我们来了解一下TCP连接的建立过程吧。</p><hr><p>C –SYN–&gt; S</p><p>S –SYN, ACK–&gt; C</p><p>C –ACK–&gt; S</p><hr><ul><li>主动发起连接的一方会发送一个SYN标记的包到目标IP</li><li>目标IP收到该SYN的包之后，会发送一个ACK的包回给主动连接方</li><li>主动连接方收到目标机的ACK包之后，会再发送一个ACK到目标IP</li></ul><p>于是双方的连接就此建立。</p><p>通俗一点的表示：</p><ul><li>A对B说，我好稀饭你，你可以做我女票嘛</li><li>B听见之后对A说，讨厌，其实我也稀饭你</li><li>A听后大喜，对B说，好啊好啊，从今以后你就是我女票了</li></ul><p>于是A和B之后就在一起了。</p><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>我们知道HTTP请求实际上是建立在TCP连接之上的。在不考虑连接复用的前提下，实际上每次HTTP请求的初始阶段都要经历TCP的三次握手。下面这个图可以很清楚的看到HTTP请求建立连接阶段的三次握手，以及最后关闭连接时的四次挥手。</p><p><img src="http.jpeg" alt="http请求"></p><p>抽丝剥茧，我们在一大堆的TCP包里面，找到了返回ep节点列表的HTTP响应。将其中的ep节点列表提取出来，作为过滤条件，将所有ep节点相关的请求都过滤出来。</p><p>结果发现了这样一个人间悲剧:</p><p><img src="tcpretransimission.jpeg" alt="超时重传"></p><p>真的向9个节点分别都请求建立连接，但是9个节点竟然都不给我回应，导致出现了TCP包的超时重传<code>Retrainsmission</code>。</p><p>(可以观察到，在iOS上，TCP包的超时重传头几次基本上是一秒一次。而在电脑上基本是按指数级别递增的).</p><p>随后一直超时重传最终触发了信令SDK里的超时逻辑，重新去请求进教室接口获取ep节点，并重新ping这些ep节点。不幸的是，这之后的尝试依然失败。</p><h3 id="案发现场"><a href="#案发现场" class="headerlink" title="案发现场"></a>案发现场</h3><p>经过上述的追查，总算能基本上将案发现场还原了，信令SDK获取到了ep节点列表，并正确的发起了9个请求去尝试连接这9个ep节点。但是这9个ep节点都没有回应。</p><p>这里引发TCP包的超时重传的直接原因就是: <em>客户端发起了SYN包，但是一直未能收到ACK包，因此客户端尝试重新发送SYN包</em>.</p><p>同时我们也能观察到，在尝试和ep节点建立连接的过程当中，有其他请求的TCP连接是正常工作的，能正常的收发包。<em>因此当下客户端的网络是好的，也并没有受到连接数的限制</em>.</p><h3 id="可能的结案"><a href="#可能的结案" class="headerlink" title="可能的结案"></a>可能的结案</h3><p>请求确实发出了，但是没连上。而客户端网络又没有问题。带着这强烈的好奇心，搜索了一下。结果发现还真有一些结论符合我们的现象。</p><blockquote><p>服务端系统内核中开启了<code>tcp_tw_recycle</code>，当多个客户端使用同一个外网IP，连接到服务端，60s内发来的connect请求中时间戳必须是递增的，否则较老时间戳的包会被视为老包丢弃。</p></blockquote><h4 id="tcp-tw-recycle"><a href="#tcp-tw-recycle" class="headerlink" title="tcp_tw_recycle"></a>tcp_tw_recycle</h4><p>这个东东是做什么的呢？</p><p>长话短说，主动关闭TCP连接的一方，会在四次挥手之后进入TIME_WAIT状态。这个状态会等待2个MSL的时间，大约是几分钟，这个连接才会真正被关闭。这段时间内这个连接是不能被回收的。期间如果要建立新连接，只能启用一个新的端口。如果短时间内有大量的连接，很有可能导致端口被耗尽。不过值得注意的是，TIME_WAIT状态只会出现在主动关闭TCP连接的一方。</p><p>为什么是2个MSL时间呢，MSL是指段最大生存时间，或者说报文最大生存时间，他是任何报文在网络上能存在的最长时间，超过这个时间报文就会被丢弃。在主动关闭连接的一方最后一次挥手发出ACK后，对方如果没有收到最后这次ACK，对方还会重发一次第三次挥手的FIN包，这时候主动关闭连接的一方还可以重发一次第四次挥手的ACK包。等待2个MSL的时间可以保证对方如果有包迟到，本方也不可能再接到这个迟到的包了，这时候复用连接的端口就不会有冲突了。</p><p>系统内核中的<code>tcp_tw_recycle</code>就是用来加快这种连接的回收。开启的情况下允许协议在2个RTT的时间内就可以进行连接回收。这样的好处是加快连接的复用。<br>同时内核中是这样处理SYN包的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_PAWS_MSL    60      <span class="comment">/* Per-host timestamps are invalidated</span></span></span><br><span class="line"><span class="meta"><span class="comment">                     * after this time. It should be equal</span></span></span><br><span class="line"><span class="meta"><span class="comment">                     * (or greater than) TCP_TIMEWAIT_LEN</span></span></span><br><span class="line"><span class="meta"><span class="comment">                     * to provide reliability equal to one</span></span></span><br><span class="line"><span class="meta"><span class="comment">                     * provided by timewait state.</span></span></span><br><span class="line"><span class="meta"><span class="comment">                     */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_PAWS_WINDOW 1       <span class="comment">/* Replay window for per-host</span></span></span><br><span class="line"><span class="meta"><span class="comment">                     * timestamps. It must be less than</span></span></span><br><span class="line"><span class="meta"><span class="comment">                     * minimal timewait lifetime.</span></span></span><br><span class="line"><span class="meta"><span class="comment"></span></span></span><br><span class="line"><span class="meta"><span class="comment"></span></span></span><br><span class="line"><span class="meta"><span class="comment">        /* VJ's idea. We save last timestamp seen</span></span></span><br><span class="line"><span class="meta"><span class="comment">         * from the destination in peer table, when entering</span></span></span><br><span class="line"><span class="meta"><span class="comment">         * state TIME-WAIT, and check against it before</span></span></span><br><span class="line"><span class="meta"><span class="comment">         * accepting new connection request.</span></span></span><br><span class="line"><span class="meta"><span class="comment">         *</span></span></span><br><span class="line"><span class="meta"><span class="comment">         * If "isn" is not zero, this request hit alive</span></span></span><br><span class="line"><span class="meta"><span class="comment">         * timewait bucket, so that all the necessary checks</span></span></span><br><span class="line"><span class="meta"><span class="comment">         * are made in the function processing timewait state.</span></span></span><br><span class="line"><span class="meta"><span class="comment">         */</span></span></span><br><span class="line">        <span class="keyword">if</span> (tmp_opt.saw_tstamp &amp;&amp;</span><br><span class="line">            tcp_death_row.sysctl_tw_recycle &amp;&amp;</span><br><span class="line">            (dst = inet_csk_route_req(sk, &amp;fl4, req)) != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            fl4.daddr == saddr &amp;&amp;</span><br><span class="line">            (peer = rt_get_peer((struct rtable *)dst, fl4.daddr)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            inet_peer_refcheck(peer);</span><br><span class="line">            <span class="keyword">if</span> ((u32)get_seconds() - peer-&gt;tcp_ts_stamp &lt; TCP_PAWS_MSL &amp;&amp;</span><br><span class="line">                (s32)(peer-&gt;tcp_ts - req-&gt;ts_recent) &gt;</span><br><span class="line">                            TCP_PAWS_WINDOW) &#123;</span><br><span class="line">                NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PAWSPASSIVEREJECTED);</span><br><span class="line">                <span class="keyword">goto</span> drop_and_release;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以看到当满足下面所有的条件时，这个SYN包将会被丢弃，然后释放相关内存。</p><ol><li>tcp的option有 time stamp字段.</li><li>tcp_tw_recycle有设置。</li><li>在路由表中是否存在完全相同的流，如果存在则直接返回.</li><li>并且数据包的源地址和新请求的源地址相同.</li><li>根据路由表以及源地址能够查找到保存的peer.</li><li>当前时间(接收到SYN)比最后一次的时间(time stamp)小于60秒.</li><li>已经存在peer的最近一次时间戳要大于当前请求进来的时间戳.</li></ol><p>时间戳是怎么得来的呢？回顾一下我们上面的抓包截图，可以看到在SYN包的后面会有一项<code>TSVal</code>，这个就是代码里用到的时间戳。也可以观察到这个时间戳并不是一个unix时间戳，实际上是CPU的启动时间。因此这个时间戳只能保证这一次连接过程中包的时间顺序，而不能保证多个连接之间的时间顺序。</p><p>我们再来回顾一下我们遇到的网络问题。看是否能对上这个结论</p><ul><li>我们使用公司的办公网络，出口IP很大概率是同一个。</li><li>有一次复现的现象是，郭老师一登老师端，之后我再使用iPad进入教室就会一直ping失败。无论是切课还是重新进教室。直到稍微过一会儿再进就OK。</li></ul><p>简单分析一下：</p><p>我们使用了同一个IP连接到服务端，老师端先和服务端连接上了，之后学生紧接着也尝试和服务端建立连接，这时候服务端发现来一个比之前的时间戳更老的包，于是认为这是一个老包，将之丢弃。</p><p>客户端一直没有收到ACK，于是超时重传，更进一步的，触发了信令SDK的超时逻辑。</p><p>感觉已经很接近事情的真相了，当然目前服务端的同学还在尝试进一步验证这个结论。</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>无论最终这次进教室失败表面看来的网络错误，背后的真因究竟如何。我自己还是从这次事件中感受良多。</p><p>网络问题我们总是遇到，但大多数情况下可能我们只是简单的认为网不好，之后就不了了之。其实很有可能背后隐藏了很多东西，如果细细发掘一下，会有不少的收获。</p><p>不光网络问题，当有一个看似非常简单浅显的问题抛出来的时候，我们还是应该多想想，有没有可能并没有我们想的那么简单。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重新审视“网络连接错误”&quot;&gt;&lt;a href=&quot;#重新审视“网络连接错误”&quot; class=&quot;headerlink&quot; title=&quot;重新审视“网络连接错误”&quot;&gt;&lt;/a&gt;重新审视“网络连接错误”&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>当Swift的泛型继承遇见NSObject</title>
    <link href="http://yiyangest.github.io/2016/06/17/when-swift-generic-inheritance-meets-nsobject/"/>
    <id>http://yiyangest.github.io/2016/06/17/when-swift-generic-inheritance-meets-nsobject/</id>
    <published>2016-06-17T03:33:41.000Z</published>
    <updated>2018-02-27T10:06:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是在一个项目里遇到的坑，不过能出现的条件还是比较特别的，可能在大多数项目当中并不会出现。在此还是记录一下。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一个泛型基类，假设有子类继承此基类，并在子类的泛型约束中指定类型必须是<code>NSObject</code>的子类。如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseA</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(whenSuccess successHandler: T?-&gt;Void)</span></span> &#123;</span><br><span class="line">        <span class="comment">//Do something and when success call successHandler(result)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildB</span>&lt;<span class="title">T</span>:<span class="title">NSObject</span>&gt;: <span class="title">BaseA</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(whenSuccess successHandler: T?-&gt;Void)</span></span> &#123;</span><br><span class="line">        <span class="comment">//Do something and when success call successHandler(result)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你实例化一个子类对象，并调用子类对象的<code>execute</code>方法，那么恭喜你，你就中招了。比如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="type">ChildB</span>&lt;<span class="type">NSString</span>&gt;()</span><br><span class="line">b.execute()&#123;</span><br><span class="line">    result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"ChildB result: \(result)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，程序很快挂掉，并为你指出发生了一个<code>EXC_BAD_ACCESS</code>的错误。</p><a id="more"></a><p>为了证明这个是<code>NSObject</code>的锅，我们可以再定义一个子类，这个子类的泛型约束中不再指定类型必须是<code>NSObject</code>的子类。如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildC</span>&lt;<span class="title">T</span>:<span class="title">Any</span>&gt;: <span class="title">BaseA</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(whenSuccess successHandler: T?-&gt;Void)</span></span> &#123;</span><br><span class="line">        <span class="comment">//Do something and when success call successHandler(result)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="type">ChildC</span>&lt;<span class="type">NSString</span>&gt;()</span><br><span class="line"><span class="built_in">c</span>.execute()&#123;</span><br><span class="line">    result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"ChildC result: \(result)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行，ChildC对象执行过程中并没有报错。</p><p>这个内存异常和继承有关系吗？我们可以再试试，定义一个泛型类，不继承任何类，只是在约束中指定类型必须是<code>NSObject</code>的子类。如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseB</span>&lt;<span class="title">T</span>:<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(whenSuccess successHandler: T?-&gt;Void)</span></span> &#123;</span><br><span class="line">        <span class="comment">//Do something and when success call successHandler(result)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baseB = <span class="type">BaseB</span>&lt;<span class="type">NSString</span>&gt;()</span><br><span class="line">baseB.execute()&#123;</span><br><span class="line">    result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"BaseB result: \(result)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，BaseB对象执行过程中并没有报错。BaseB与ChildB的唯一区别就是ChildB有继承关系。</p><p>我们可以再试着改写一下，定义一个子类，这个子类的泛型约束同ChildB一样，但是不再重写父类中的execute方法。如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildD</span>&lt;<span class="title">T</span>:<span class="title">NSObject</span>&gt;: <span class="title">BaseA</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// no more override func execute()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="type">ChildD</span>&lt;<span class="type">NSString</span>&gt;()</span><br><span class="line">d.execute()&#123;</span><br><span class="line">    result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"ChildD result: \(result)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，多年的<code>EXC_BAD_ACCESS</code>病也治好了！</p><p>可以总结归纳一下，出现这种情况的<code>EXC_BAD_ACCESS</code>必须满足以下几个条件：</p><ul><li>子类中的泛型约束必须指定为<code>NSObject</code>的子类；</li><li>子类必须重写父类中的方法；</li><li>重写的方法中，必须有闭包引用泛型，例如：<code>T?-&gt;Void</code>；</li></ul><p>应该来说还是比较难出现这种情况的。碰巧被我赶上了…</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>这里可以介绍一下场景，场景是一个很常见的场景，但是在作代码架构设计的时候不小心搞出了这个妖蛾子。</p><p>在Swift中解析JSON并转为相应的Model，常用的库有<a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="noopener">ObjectMapper</a>，<a href="https://github.com/thoughtbot/Argo" target="_blank" rel="noopener">Argo</a>等，不过这些库都有一个问题，就是必须手动的将模型的属性和JSON字串里的key一一对应。当然这并不能赖这些库不好，而是Swift里的类并不具备OC运行时的特性（除非加了<code>@objc</code>关键字)，而目前Swift里的反射还非常的弱，只能读取类属性和类的值，并不能利用反射为类属性赋值。手写代码一一对应并不是什么难事，可问题是程序员都是懒的，碰见一个二十多甚至更多属性的类，顿时就不想再这么手写下去了。OC时代早就不这么手写代码对应了，于是只好想了一个办法，将OC的模型映射库(比如<a href="https://github.com/ibireme/YYModel" target="_blank" rel="noopener">YYModel</a>)作一个桥接，让Swift代码也可以调用这个库。问题在于YYModel这类OC的映射库都是利用了OC的运行时机制，因此Swift类想要用YYModel，就只能继承于<code>NSObject</code>，让它也具有运行时的特性。<br>于是设计了一个模型基类继承于<code>NSObject</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span>: <span class="title">NSObject</span>, <span class="title">NSCoding</span> </span>&#123;</span><br><span class="line">    <span class="comment">// properties</span></span><br><span class="line">    <span class="comment">// methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网络部分利用<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a>去请求API，并将返回的JSON解析为对应的Model。为此封装了一下<code>Alamofire</code>作为网络请求的底层：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkEngine</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... other network methods</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doPost</span>&lt;T: NSObject&gt;<span class="params">(url: String, byParams params: [String: AnyObject], whenSuccess successHandler: T? -&gt; Void, whenError errorHandler: ErrorHandler?)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//... other network methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外设计了一个网络API类，负责接收网络API的URL及请求参数，并对请求参数作加密等处理，内部调用封装好的<code>NetworkEngine</code>去发起请求，并将解析完的Model结果通过闭包返回给上层。<br>因为有些网络请求回来的结果需要映射到一个Model上，而也有小部分网络请求回来的结果并不需要映射到Model上，比如仅仅是一个<code>true</code>或者<code>false</code>，为此也创建Model似乎不太值当。于是设计了两种处理不同类型的网络API子类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseAPI</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// properties</span></span><br><span class="line">    <span class="comment">// other methods</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(whenSuccess successHandler: T?-&gt;Void, whenError: ErrorHandler?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// call NetworkEngine.doPost() and when success call successHandler to return T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelAPI</span>&lt;<span class="title">T</span>:<span class="title">BaseModel</span>&gt;: <span class="title">BaseAPI</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(whenSuccess successHandler: T?-&gt;Void, whenError: ErrorHandler?)</span></span> &#123;</span><br><span class="line">        networkEngine.doPost(url, byParams: params, whenSuccess: successHandler, whenError: whenError)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DictAPI</span>: <span class="title">BaseAPI</span>&lt;[<span class="title">String</span>: <span class="title">AnyObject</span>]&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(whenSuccess successHandler: [String: AnyObject]?-&gt;Void, whenError: ErrorHandler?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// call NetworkEngine.doPost() and when success call successHandler to return [String: AnyObject]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是在上层实例化<code>ModelAPI</code>对象时，就悲剧了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> loginAPI = <span class="type">ModelAPI</span>&lt;<span class="type">Account</span>&gt;(url: <span class="string">""</span>, params: [<span class="string">"..."</span>: <span class="string">"..."</span>])</span><br><span class="line">loginAPI.execute(whenSuccess: &#123;</span><br><span class="line">    user <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// handle logined user</span></span><br><span class="line">    <span class="comment">// crashed and point EXC_BAD_ACCESS problem.</span></span><br><span class="line">    &#125;, whenError: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>于是乎只好重新设计一下网络层，绕过这个坑。</p><h2 id="内幕"><a href="#内幕" class="headerlink" title="内幕(?)"></a>内幕(?)</h2><p>没有内幕。。。</p><p>好吧，虽然调试找原因花了很长的时间才定位到是继承重写泛型类闹的，但是依然没有找到这一过程的内幕究竟发生了些什么导致内存异常的。大致的推断可能是Swift兼容OC的一个Bug。。。（什么鬼，裤子都脱了给我看这个…）<br>可能涉及的点有：</p><ul><li><p>Swift的运行时机制是和OC完全不同的一套，OC采用消息转发、动态派发等方式来在运行时动态决定实际调用的实现。而Swift采用了一套类似于C++里的虚拟函数表(<code>vtable</code>)的机制，在编译时就确定调用方法的实现。</p></li><li><p>继承于<code>NSObject</code>的类，编译器会隐式的给其属性自动加上<code>@objc</code>的注解，使其具有OC运行时的特性。</p></li><li><p>闭包类似于OC中的block，闭包会隐式的持有内部用到的外部变量的强引用。</p></li></ul><p>暂时就这么多了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是在一个项目里遇到的坑，不过能出现的条件还是比较特别的，可能在大多数项目当中并不会出现。在此还是记录一下。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;一个泛型基类，假设有子类继承此基类，并在子类的泛型约束中指定类型必须是&lt;code&gt;NSObject&lt;/code&gt;的子类。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BaseA&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(whenSuccess successHandler: T?-&amp;gt;Void)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//Do something and when success call successHandler(result)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ChildB&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;:&lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&amp;gt;: &lt;span class=&quot;title&quot;&gt;BaseA&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(whenSuccess successHandler: T?-&amp;gt;Void)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//Do something and when success call successHandler(result)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当你实例化一个子类对象，并调用子类对象的&lt;code&gt;execute&lt;/code&gt;方法，那么恭喜你，你就中招了。比如：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = &lt;span class=&quot;type&quot;&gt;ChildB&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;NSString&lt;/span&gt;&amp;gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b.execute()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ChildB result: \(result)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行，程序很快挂掉，并为你指出发生了一个&lt;code&gt;EXC_BAD_ACCESS&lt;/code&gt;的错误。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift Generic NSObject" scheme="http://yiyangest.github.io/tags/Swift-Generic-NSObject/"/>
    
  </entry>
  
  <entry>
    <title>构建2016 F8 app</title>
    <link href="http://yiyangest.github.io/2016/04/22/building-the-f8-2016-app/"/>
    <id>http://yiyangest.github.io/2016/04/22/building-the-f8-2016-app/</id>
    <published>2016-04-21T16:00:00.000Z</published>
    <updated>2018-02-27T10:06:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="App准备阶段"><a href="#App准备阶段" class="headerlink" title="App准备阶段"></a>App准备阶段</h2><p><em>这是在开发F8 2016大会iOS和Android客户端过程中写下的一系列用来介绍React Native和它的开源生态圈的教程.</em></p><p>在第一部分，我们将讲述是如何计划准备这款app的；后续部分我们将分享一些示例代码，讨论如何考虑多平台设计，分析我们app当中的数据层，并且解释我们的测试策略。</p><a id="more"></a><h3 id="切换到React-Native"><a href="#切换到React-Native" class="headerlink" title="切换到React Native"></a>切换到React Native</h3><p>在2015年，F8开发者大会的iOS客户端是用React Native来开发的，但是Android版本仍然是用原生代码开发的；在前几年，两个平台都是使用各自iOS和Android的原生代码开发的。从2015开发者大会以后，React Native也发布了Android版本，而这也代表了一个可以分离app的逻辑和UI代码的契机。一些Facebook团队已经发现当使用React Native时有<a href="https://code.facebook.com/posts/1189117404435352/react-native-for-android-how-we-built-the-first-cross-platform-react-native-app/" target="_blank" rel="noopener">大约85%的app代码可以复用</a>。</p><p>React Native还具有可以在同UI设计师紧密合作过程中快速将可视化组件制作成原型的好处 －－ 我们将会在第二部分讨论。</p><p>因此，如果我们要切换到React Native，还有什么别的需要我们去考虑的？让我们从内容开始。</p><h3 id="选择数据层"><a href="#选择数据层" class="headerlink" title="选择数据层"></a>选择数据层</h3><p>2014和2015的F8 app都使用<a href="https://parse.com" target="_blank" rel="noopener">Parse云服务</a>来作为数据后端。因此当开始计划2016的F8 app时，Parse有重用现有的数据架构快速开始的优势。</p><p>使用Parse也有一些其它的原因 － app里要展示的大多数内容需要很频繁的更新，包括在会议期间，并且它要能无需任何技术专家（例如要求至少熟悉编辑excel表格）就能够更新。Parse云服务后台管理系统是满足这些需求的完美工具。</p><p>综上所述，Parse是F8 app数据后端的最佳选择。依据<a href="http://blog.parse.com/announcements/moving-on/" target="_blank" rel="noopener">Parse云服务关闭公告</a>，我们决定转移使用新开源的<a href="http://blog.parse.com/announcements/introducing-parse-server-and-the-database-migration-tool/" target="_blank" rel="noopener">Parse服务端</a>和<a href="https://github.com/ParsePlatform/parse-dashboard" target="_blank" rel="noopener">Parse后台管理系统</a>。</p><p>由于React Native并不需要和数据层紧密相联，例如React Native的UI和逻辑部分的开发可以通过简单的模拟数据来完成。这意味着只要数据层的结构保持不变，你可以花费最小的调整来切换一个开发好的app的数据源。对于F8 App来说，这意味着在app已经开发完后，我们仍可以非常轻松的将Parse云服务迁移到开源的Parse服务端。我们会在数据教程部分介绍更多这方面的内容。</p><h3 id="React-Native的数据访问"><a href="#React-Native的数据访问" class="headerlink" title="React Native的数据访问"></a>React Native的数据访问</h3><p>为了整合Parse和React Native，虽然已经有一个现成的<a href="https://github.com/ParsePlatform/ParseReact" target="_blank" rel="noopener">Parse+React包</a>，提供了必要的绑定工具，但仍有一个问题 － 由于会议无线网络连接的不稳定性，F8 app必须能够在离线的情况下使用。因为在F8 app开发阶段，Parse+React还并不支持离线同步数据，所以我们必须构建我们自己的离线支持。</p><p>在做这些决定的时候还有另一个影响因素 － 团队大小。例如Relay更适合于一个有一定规模的大团队，但是F8 app只有一个人开发，加上另一些设计支持。这对你开发app时使用哪种类型的数据读取方式有很大影响。</p><p>那<a href="http://graphql.org/" target="_blank" rel="noopener">GraphQL</a>和<a href="https://facebook.github.io/relay/" target="_blank" rel="noopener">Relay</a>怎么样？尽管它们非常适合React Native，但<a href="https://github.com/facebook/relay/wiki/Roadmap#in-progress" target="_blank" rel="noopener">那时候</a>Relay还不支持离线使用，而GraphQL不支持在Parse之外使用。使用这些方法开发app要求开发一套GraphQL-Parse的API和Relay的离线存储方法。</p><p>GrapQL服务端的搭建对一个人短时间内来说有一些复杂。记住当我们要在app store发布这款app，我们想要的是最简单最快速的方法，那还有哪些其它的选择呢？</p><p>考虑以上，<a href="https://github.com/rackt/redux" target="_blank" rel="noopener">Redux</a>是最佳选择。Redux提供了一个<a href="https://facebook.github.io/flux/" target="_blank" rel="noopener">Flux架构</a>的简单实现，在数据该如何存储和缓存方面提供更多的控制，本质上使app能够同Parse云服务进行单向同步。</p><p>在app商店的版本中，Redux保证了app里功能性和易用性方面的平衡。当app发布以后，我们重新考虑了这个，并且在app当中部分使用了Relay和GraphQL，我们将在附录：Relay和GrapQL中介绍这次迁移。</p><h3 id="我们的开发栈"><a href="#我们的开发栈" class="headerlink" title="我们的开发栈"></a>我们的开发栈</h3><p>有React Native作为我们选择的app框架，Redux作为数据层，我们还需要选择一些支持的技术和工具：</p><ul><li>开源的<a href="https://github.com/ParsePlatform/parse-server" target="_blank" rel="noopener">Parse服务端</a>，提供数据存储 － 运行在<a href="https://nodejs.org/en" target="_blank" rel="noopener">Node.js</a>之上。</li><li>启用<a href="http://flowtype.org/" target="_blank" rel="noopener">Flow</a>来捕获我们React Native中Javascript代码的类型错误。</li><li>使用<a href="http://facebook.github.io/jest/" target="_blank" rel="noopener">Jest框架</a>为一些复杂的方法编写单元测试。</li><li>使用<a href="https://github.com/facebook/react-native-fbsdk" target="_blank" rel="noopener">React Native Facebook SDK</a>来快速集成在iOS和Android上访问Facebook数据。</li><li>我们在OXS上使用Facebook开发的<a href="http://nuclide.io/docs/platforms/react-native/" target="_blank" rel="noopener">内置支持React Native</a>的<a href="http://nuclide.io" target="_blank" rel="noopener">Nuclide</a>编辑器。</li><li>我们使用git作为版本控制工具，并在<a href="https://github.com/fbsamples/f8app" target="_blank" rel="noopener">GitHub</a>上记录进度。</li></ul><p>我们还使用了一些其它的小工具包，我们将会在各篇教程中介绍。</p><p><em>在你进行到下一章节之前，我们建议你学习一些<a href="http://facebook.github.io/react/docs/tutorial.html" target="_blank" rel="noopener">React.js的基本知识</a> － 尤其是它的<a href="http://facebook.github.io/react/docs/thinking-in-react.html#step-1-break-the-ui-into-a-component-hierarchy" target="_blank" rel="noopener">模块化组件概念</a>和<a href="http://facebook.github.io/react/docs/jsx-in-depth.html" target="_blank" rel="noopener">JSX语法</a>。然后跟着<a href="http://facebook.github.io/react-native/docs/tutorial.html#content" target="_blank" rel="noopener">React Native的介绍教程</a>学习如何将这些应用到移动app当中。</em></p><h2 id="为多平台设计App"><a href="#为多平台设计App" class="headerlink" title="为多平台设计App"></a>为多平台设计App</h2><p>React Native的众多亮点之一是它很简单就能创建可同时运行在iOS和Android之上的app，不必要用不同的原生语言去重复编写大部分的app逻辑。</p><p>然而，React Native的哲学理念一直是”learn once, write anywhere”, 而不是”write once, run anywhere”。这个微妙的区别意味着用React Native开发的app应该为每个平台量身定制，而不是完全一模一样。</p><p>从UI层面来看，由于平台在可视化样式、UI范例，甚至是技术能力上都有或多或少的区别，那从一个公共的UI基础样式开始，然后对每个平台做微调就显得很有必要。</p><h4 id="在我们开始之前"><a href="#在我们开始之前" class="headerlink" title="在我们开始之前"></a>在我们开始之前</h4><p>在这个和接下来的教程里，我们将会深入到app本身的代码中，因此你应该将<a href="https://github.com/fbsamples/f8app" target="_blank" rel="noopener">源代码</a>克隆到任何一个你方便查看的地方。你还可以根据<a href="http://makeitopen.com/tutorials/building-the-f8-app/local-setup/" target="_blank" rel="noopener">我们的安装指南</a>在你本地运行此app，但是如果仅为了此篇教程，你只需要可以查看浏览源代码即可。</p><h3 id="React-Native思维模式"><a href="#React-Native思维模式" class="headerlink" title="React Native思维模式"></a>React Native思维模式</h3><p>在我们写任何React代码之前，有一个很重要的概念会指明你如何思考一个React app的每一处细节。这个概念就是<strong>你的代码应尽可能的重用</strong>.</p><p>这似乎和为每一个平台量身定制视觉效果的想法有些矛盾 － 这个量身定制的想法可能会创建独立分开的iOS和Android可视化组件 － 但这也要求React Native开发的app仍要尽可能多的共享重叠的部分。</p><p>当考虑开发React Native app中的可视化组件时，成功的关键是使用平台抽象。开发者和设计师制定一系列app中的可复用组件 － 例如”button”, “container”, “list row”, “header”等等 － 只有当需要的时候，才从这些公共的版本中演化出其它组件。</p><p>当然，一些组件会比其它组件复杂的多，那就让我们来探索一下F8 app当中的一些不同的组件。</p><h3 id="差异化小组件"><a href="#差异化小组件" class="headerlink" title="差异化小组件"></a>差异化小组件</h3><p>这是F8 app当中的一个例子：</p><p><img src="https://raw.githubusercontent.com/facebook/makeitopen/gh-pages/static/images/iOS%20vs%20Android%20Segmented%20Controls%403x.png" alt="iOS和Android的Segmented Controls的对比"></p><p>在iOS当中，tab控件使用iOS用户很熟悉的圆角按钮样式，而Android版本的这个控件使用更贴合平台的下划线样式。不管怎样，两个控件具有完全相同的功能。</p><p>因此，尽管视觉上它们有细微的不同，但是还是很值得重复强调它们应当<strong>尽可能的重用代码</strong>。</p><p>对于一个类似这样的小组件，跨平台的时候在牵涉到的逻辑上我们有很大一部分是重叠的 － 它展示文本按钮，具有’hover’和’active’的样式，唯一区别是细微的样式差异 － 因此最好的方式是用一个单一的组件，然后在必要的时候使用控制语句来实现此组件。</p><p>接下来以上面这个组件作为一个例子（来自于<code>&lt;F8SegmentedControl&gt;</code>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/common/F8SegmentedControl.js */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Segment</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: string;</span><br><span class="line">    isSelected: boolean;</span><br><span class="line">    selectionColor: string;</span><br><span class="line">    onPress: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">var</span> selectedButtonStyle;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.isSelected) &#123;</span><br><span class="line">      selectedButtonStyle = &#123; <span class="attr">borderColor</span>: <span class="keyword">this</span>.props.selectionColor &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> deselectedLabelStyle;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.props.isSelected &amp;&amp; Platform.OS === <span class="string">'android'</span>) &#123;</span><br><span class="line">      deselectedLabelStyle = styles.deselectedLabel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> title = <span class="keyword">this</span>.props.value &amp;&amp; <span class="keyword">this</span>.props.value.toUpperCase();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> accessibilityTraits = [<span class="string">'button'</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.isSelected) &#123;</span><br><span class="line">      accessibilityTraits.push(<span class="string">'selected'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;TouchableOpacity</span><br><span class="line">        accessibilityTraits=&#123;accessibilityTraits&#125;</span><br><span class="line">        activeOpacity=&#123;<span class="number">0.8</span>&#125;</span><br><span class="line">        onPress=&#123;<span class="keyword">this</span>.props.onPress&#125;</span><br><span class="line">        style=&#123;[styles.button, selectedButtonStyle]&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;[styles.label, deselectedLabelStyle]&#125;&gt;</span><br><span class="line">          &#123;title&#125;</span><br><span class="line">        &lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>TouchableOpacity&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们简单的根据代码所运行的平台(使用React Native的<a href="https://facebook.github.io/react-native/docs/platform-specific-code.html#platform-module" target="_blank" rel="noopener">Platform模块</a>)来设置不同的样式。两个平台的tab按钮都接受一些共同的样式，但是又有所不同（仍然来自<code>&lt;F8SegmentedControl&gt;</code>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/common/F8SegmentedControl.js */</span></span><br><span class="line"><span class="keyword">var</span> styles = F8StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    flexDirection: <span class="string">'row'</span>,</span><br><span class="line">    backgroundColor: <span class="string">'transparent'</span>,</span><br><span class="line">    ios: &#123;</span><br><span class="line">      paddingBottom: <span class="number">6</span>,</span><br><span class="line">      justifyContent: <span class="string">'center'</span>,</span><br><span class="line">      alignItems: <span class="string">'center'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    android: &#123;</span><br><span class="line">      paddingLeft: <span class="number">60</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  button: &#123;</span><br><span class="line">    borderColor: <span class="string">'transparent'</span>,</span><br><span class="line">    alignItems: <span class="string">'center'</span>,</span><br><span class="line">    justifyContent: <span class="string">'center'</span>,</span><br><span class="line">    backgroundColor: <span class="string">'transparent'</span>,</span><br><span class="line">    ios: &#123;</span><br><span class="line">      height: HEIGHT,</span><br><span class="line">      paddingHorizontal: <span class="number">20</span>,</span><br><span class="line">      borderRadius: HEIGHT / <span class="number">2</span>,</span><br><span class="line">      borderWidth: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    android: &#123;</span><br><span class="line">      paddingBottom: <span class="number">6</span>,</span><br><span class="line">      paddingHorizontal: <span class="number">10</span>,</span><br><span class="line">      borderBottomWidth: <span class="number">3</span>,</span><br><span class="line">      marginRight: <span class="number">10</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  label: &#123;</span><br><span class="line">    letterSpacing: <span class="number">1</span>,</span><br><span class="line">    fontSize: <span class="number">12</span>,</span><br><span class="line">    color: <span class="string">'white'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  deselectedLabel: &#123;</span><br><span class="line">    color: <span class="string">'rgba(255, 255, 255, 0.7)'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里我们使用了一个经过修改的<a href="https://facebook.github.io/react-native/docs/stylesheet.html" target="_blank" rel="noopener">React Native StyleSheet API</a>，包含了一些额外的可以根据平台自动切换样式的功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">styles: Object</span>): </span>&#123;[name: string]: number&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> platformStyles = &#123;&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.keys(styles).forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;ios, android, ...style&#125; = &#123;...styles[name]&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ios &amp;&amp; Platform.OS === <span class="string">'ios'</span>) &#123;</span><br><span class="line">      style = &#123;...style, ...ios&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (android &amp;&amp; Platform.OS === <span class="string">'android'</span>) &#123;</span><br><span class="line">      style = &#123;...style, ...android&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    platformStyles[name] = style;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> StyleSheet.create(platformStyles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个<code>F8StyleSheet</code>方法中，我们解析所提供的对象(之前代码示例中的<code>styles</code>对象)，如果我们发现有一个key叫做<code>ios</code>或者<code>android</code>，并且符合app正运行的平台，那我们会使用这个key对应的样式，如果不符合正运行的平台，那这部分代码将被忽略。这给我们提供了另一个简单的例子来说明React的尽可能重用共同的样式代码来减少代码重复的思路。</p><p>现在我们可以在app当中重用这个组件，并且它会根据iOS或者Android使用适当的样式。</p><h3 id="分离复杂的差别"><a href="#分离复杂的差别" class="headerlink" title="分离复杂的差别"></a>分离复杂的差别</h3><p>当一个组件在两个平台上的实现在逻辑上没有多少可共享的，并且不光在外观上有所不同，我们需要另一种实现方式。下面这个例子是app中最顶层的菜单导航：</p><p><img src="https://raw.githubusercontent.com/facebook/makeitopen/gh-pages/static/images/iOS vs. Android@3x.png" alt="iOS和Android主导航比较"></p><p>正如你所看见的，iOS版本的导航是在屏幕下方固定的tab，而Android版本则实现了一个带侧滑导航的汉堡式菜单。这在额外的动画，样式甚至是菜单项本身都有着显著的区别。Android客户端可能会包含更多的导航菜单选项，例如一个登出的选项。</p><p>你<em>可以</em>继续用一个单一的组件来实现所有这些，但是这个组件的逻辑将会充满大量的控制语句，并且这很快就会使代码变的难以理解。</p><p>取而代之的是，我们可以利用React Native内置的<a href="http://facebook.github.io/react-native/docs/platform-specific-code.html#platform-specific-extensions" target="_blank" rel="noopener">指定平台扩展名</a>的优势。我们将创建两个不同的组件，在这个例子当中一个叫做<code>F8TabsView.ios.js</code>，另一个叫做<code>F8TabsView.android.js</code> - React Native会自动检测并且根据不同的扩展名为各个平台加载正确的组件。</p><h4 id="内建的UI组件"><a href="#内建的UI组件" class="headerlink" title="内建的UI组件"></a>内建的UI组件</h4><p>在每个<code>FBTabsView</code>组件内部，我们仍然可以使用一些内建的React Native UI元素。Android版本使用了<code>DrawerLayoutAndroid</code>(你可以根据组件的名字来推断出这只在Android app当中有效)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/tabs/F8TabsView.android.js */</span></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;DrawerLayoutAndroid</span><br><span class="line">      ref=<span class="string">"drawer"</span></span><br><span class="line">      drawerWidth=&#123;<span class="number">300</span>&#125;</span><br><span class="line">      drawerPosition=&#123;DrawerLayoutAndroid.positions.Left&#125;</span><br><span class="line">      renderNavigationView=&#123;<span class="keyword">this</span>.renderNavigationView&#125;&gt;</span><br><span class="line">      &lt;View style=&#123;styles.content&#125; key=&#123;<span class="keyword">this</span>.props.activeTab&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.renderContent()&#125;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>DrawerLayoutAndroid&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第8行，我们指引这个drawer组件去寻找这个类当中的<code>renderNavigationView()</code>方法。这个方法会返回打开的抽屉(drawer)中要显示的内容。在这个例子当中，我们将会显示一个<a href="http://facebook.github.io/react-native/docs/scrollview.html" target="_blank" rel="noopener"><code>ScrollView</code></a>组件，ScrollView内部由自定义的<code>MenuItem</code>组件(参考<a href="https://github.com/fbsamples/f8app/blob/master/js/tabs/MenuItem.js" target="_blank" rel="noopener"><code>MenuItem.js</code></a>)填充：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/tabs/F8TabsView.android.js */</span></span><br><span class="line">renderNavigationView() &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    &lt;ScrollView style=&#123;styles.drawer&#125;&gt;</span><br><span class="line">      &lt;MenuItem</span><br><span class="line">        title=<span class="string">"Schedule"</span></span><br><span class="line">        selected=&#123;<span class="keyword">this</span>.props.activeTab === <span class="string">'schedule'</span>&#125;</span><br><span class="line">        onPress=&#123;<span class="keyword">this</span>.onTabSelect.bind(<span class="keyword">this</span>, <span class="string">'schedule'</span>)&#125;</span><br><span class="line">        icon=&#123;scheduleIcon&#125;</span><br><span class="line">        selectedIcon=&#123;scheduleIconSelected&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;MenuItem</span><br><span class="line">        title=<span class="string">"My F8"</span></span><br><span class="line">        selected=&#123;<span class="keyword">this</span>.props.activeTab === <span class="string">'my-schedule'</span>&#125;</span><br><span class="line">        onPress=&#123;<span class="keyword">this</span>.onTabSelect.bind(<span class="keyword">this</span>, <span class="string">'my-schedule'</span>)&#125;</span><br><span class="line">        icon=&#123;<span class="built_in">require</span>(<span class="string">'./schedule/img/my-schedule-icon.png'</span>)&#125;</span><br><span class="line">        selectedIcon=&#123;<span class="built_in">require</span>(<span class="string">'./schedule/img/my-schedule-icon-active.png'</span>)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;MenuItem</span><br><span class="line">        title=<span class="string">"Map"</span></span><br><span class="line">        selected=&#123;<span class="keyword">this</span>.props.activeTab === <span class="string">'map'</span>&#125;</span><br><span class="line">        onPress=&#123;<span class="keyword">this</span>.onTabSelect.bind(<span class="keyword">this</span>, <span class="string">'map'</span>)&#125;</span><br><span class="line">        icon=&#123;<span class="built_in">require</span>(<span class="string">'./maps/img/maps-icon.png'</span>)&#125;</span><br><span class="line">        selectedIcon=&#123;<span class="built_in">require</span>(<span class="string">'./maps/img/maps-icon-active.png'</span>)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;MenuItem</span><br><span class="line">        title=<span class="string">"Notifications"</span></span><br><span class="line">        selected=&#123;<span class="keyword">this</span>.props.activeTab === <span class="string">'notifications'</span>&#125;</span><br><span class="line">        onPress=&#123;<span class="keyword">this</span>.onTabSelect.bind(<span class="keyword">this</span>, <span class="string">'notifications'</span>)&#125;</span><br><span class="line">        badge=&#123;<span class="keyword">this</span>.state.notificationsBadge&#125;</span><br><span class="line">        icon=&#123;<span class="built_in">require</span>(<span class="string">'./notifications/img/notifications-icon.png'</span>)&#125;</span><br><span class="line">        selectedIcon=&#123;<span class="built_in">require</span>(<span class="string">'./notifications/img/notifications-icon-active.png'</span>)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;MenuItem</span><br><span class="line">        title=<span class="string">"Info"</span></span><br><span class="line">        selected=&#123;<span class="keyword">this</span>.props.activeTab === <span class="string">'info'</span>&#125;</span><br><span class="line">        onPress=&#123;<span class="keyword">this</span>.onTabSelect.bind(<span class="keyword">this</span>, <span class="string">'info'</span>)&#125;</span><br><span class="line">        icon=&#123;<span class="built_in">require</span>(<span class="string">'./info/img/info-icon.png'</span>)&#125;</span><br><span class="line">        selectedIcon=&#123;<span class="built_in">require</span>(<span class="string">'./info/img/info-icon-active.png'</span>)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;<span class="regexp">/ScrollView&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>相较而言，iOS版本直接在<code>render()</code>方法中使用了一个不同的内建组件，<a href="http://facebook.github.io/react-native/docs/tabbarios.html" target="_blank" rel="noopener"><code>TabBarIOS</code></a>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/tabs/F8TabsView.ios.js */</span></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">var</span> scheduleIcon = <span class="keyword">this</span>.props.day === <span class="number">1</span></span><br><span class="line">    ? <span class="built_in">require</span>(<span class="string">'./schedule/img/schedule-icon-1.png'</span>)</span><br><span class="line">    : <span class="built_in">require</span>(<span class="string">'./schedule/img/schedule-icon-2.png'</span>);</span><br><span class="line">  <span class="keyword">var</span> scheduleIconSelected = <span class="keyword">this</span>.props.day === <span class="number">1</span></span><br><span class="line">    ? <span class="built_in">require</span>(<span class="string">'./schedule/img/schedule-icon-1-active.png'</span>)</span><br><span class="line">    : <span class="built_in">require</span>(<span class="string">'./schedule/img/schedule-icon-2-active.png'</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;TabBarIOS tintColor=&#123;F8Colors.darkText&#125;&gt;</span><br><span class="line">      &lt;TabBarItemIOS</span><br><span class="line">        title=<span class="string">"Schedule"</span></span><br><span class="line">        selected=&#123;<span class="keyword">this</span>.props.activeTab === <span class="string">'schedule'</span>&#125;</span><br><span class="line">        onPress=&#123;<span class="keyword">this</span>.onTabSelect.bind(<span class="keyword">this</span>, <span class="string">'schedule'</span>)&#125;</span><br><span class="line">        icon=&#123;scheduleIcon&#125;</span><br><span class="line">        selectedIcon=&#123;scheduleIconSelected&#125;&gt;</span><br><span class="line">        &lt;GeneralScheduleView</span><br><span class="line">          navigator=&#123;<span class="keyword">this</span>.props.navigator&#125;</span><br><span class="line">          onDayChange=&#123;<span class="keyword">this</span>.handleDayChange&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/TabBarItemIOS&gt;</span></span><br><span class="line"><span class="regexp">      &lt;TabBarItemIOS</span></span><br><span class="line"><span class="regexp">        title="My F8"</span></span><br><span class="line"><span class="regexp">        selected=&#123;this.props.activeTab === 'my-schedule'&#125;</span></span><br><span class="line"><span class="regexp">        onPress=&#123;this.onTabSelect.bind(this, 'my-schedule')&#125;</span></span><br><span class="line"><span class="regexp">        icon=&#123;require('./</span>schedule/img/my-schedule-icon.png<span class="string">')&#125;</span></span><br><span class="line"><span class="string">        selectedIcon=&#123;require('</span>./schedule/img/my-schedule-icon-active.png<span class="string">')&#125;&gt;</span></span><br><span class="line"><span class="string">        &lt;MyScheduleView</span></span><br><span class="line"><span class="string">          navigator=&#123;this.props.navigator&#125;</span></span><br><span class="line"><span class="string">          onJumpToSchedule=&#123;() =&gt; this.props.onTabSelect('</span>schedule<span class="string">')&#125;</span></span><br><span class="line"><span class="string">        /&gt;</span></span><br><span class="line"><span class="string">      &lt;/TabBarItemIOS&gt;</span></span><br><span class="line"><span class="string">      &lt;TabBarItemIOS</span></span><br><span class="line"><span class="string">        title="Map"</span></span><br><span class="line"><span class="string">        selected=&#123;this.props.activeTab === '</span>map<span class="string">'&#125;</span></span><br><span class="line"><span class="string">        onPress=&#123;this.onTabSelect.bind(this, '</span>map<span class="string">')&#125;</span></span><br><span class="line"><span class="string">        icon=&#123;require('</span>./maps/img/maps-icon.png<span class="string">')&#125;</span></span><br><span class="line"><span class="string">        selectedIcon=&#123;require('</span>./maps/img/maps-icon-active.png<span class="string">')&#125;&gt;</span></span><br><span class="line"><span class="string">        &lt;F8MapView /&gt;</span></span><br><span class="line"><span class="string">      &lt;/TabBarItemIOS&gt;</span></span><br><span class="line"><span class="string">      &lt;TabBarItemIOS</span></span><br><span class="line"><span class="string">        title="Notifications"</span></span><br><span class="line"><span class="string">        selected=&#123;this.props.activeTab === '</span>notifications<span class="string">'&#125;</span></span><br><span class="line"><span class="string">        onPress=&#123;this.onTabSelect.bind(this, '</span>notifications<span class="string">')&#125;</span></span><br><span class="line"><span class="string">        badge=&#123;this.state.notificationsBadge&#125;</span></span><br><span class="line"><span class="string">        icon=&#123;require('</span>./notifications/img/notifications-icon.png<span class="string">')&#125;</span></span><br><span class="line"><span class="string">        selectedIcon=&#123;require('</span>./notifications/img/notifications-icon-active.png<span class="string">')&#125;&gt;</span></span><br><span class="line"><span class="string">        &lt;F8NotificationsView navigator=&#123;this.props.navigator&#125; /&gt;</span></span><br><span class="line"><span class="string">      &lt;/TabBarItemIOS&gt;</span></span><br><span class="line"><span class="string">      &lt;TabBarItemIOS</span></span><br><span class="line"><span class="string">        title="Info"</span></span><br><span class="line"><span class="string">        selected=&#123;this.props.activeTab === '</span>info<span class="string">'&#125;</span></span><br><span class="line"><span class="string">        onPress=&#123;this.onTabSelect.bind(this, '</span>info<span class="string">')&#125;</span></span><br><span class="line"><span class="string">        icon=&#123;require('</span>./info/img/info-icon.png<span class="string">')&#125;</span></span><br><span class="line"><span class="string">        selectedIcon=&#123;require('</span>./info/img/info-icon-active.png<span class="string">')&#125;&gt;</span></span><br><span class="line"><span class="string">        &lt;F8InfoView navigator=&#123;this.props.navigator&#125; /&gt;</span></span><br><span class="line"><span class="string">      &lt;/TabBarItemIOS&gt;</span></span><br><span class="line"><span class="string">    &lt;/TabBarIOS&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看见，尽管iOS的菜单使用了许多相同的数据，但它们的结构完全不一样。<a href="http://facebook.github.io/react-native/docs/tabbarios-item.html#content" target="_blank" rel="noopener"><code>TabBarItemIOS</code></a>作为子元素被插入到父亲菜单中，而不是用一个单独的方法来创建菜单项。</p><p>这些<code>TarBarItem</code>本质上等同于Android的<code>MenuItem</code>组件 － 不同之处在于Android组件我们定义了一个单一的主<a href="(http://facebook.github.io/react-native/docs/view.html#content"><code>View</code>组件</a>来展示内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;styles.content&#125; key=&#123;<span class="keyword">this</span>.props.activeTab&#125;&gt;</span><br><span class="line">  &#123;<span class="keyword">this</span>.renderContent()&#125;</span><br><span class="line">&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure><p>并且当一个tab发生改变时会改变这个view组件（通过<code>renderContent()</code>方法），而iOS组件则有许多独立的<code>View</code>组件作为当<code>TarBarItem</code>被点击时需要显示的内容，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;GeneralScheduleView</span><br><span class="line">  navigator=&#123;<span class="keyword">this</span>.props.navigator&#125;</span><br><span class="line">  onDayChange=&#123;<span class="keyword">this</span>.handleDayChange&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h3 id="设计迭代"><a href="#设计迭代" class="headerlink" title="设计迭代"></a>设计迭代</h3><p>当你创建任何一种app，移动端的或者web端的，快速的微调和调整UI元素有时候会变的很痛苦。如果一个工程师和一个设计师一起合作，这会把整个进度拖慢。</p><p>React Native包含了一个<a href="http://facebook.github.io/react-native/docs/debugging.html#live-reload" target="_blank" rel="noopener">自动重新加载</a>的调试特性，只要Javascript代码改变就会触发app的刷新。这会缩减设计迭代的过程 － 比如改变一个组件的样式，保存，然后你就会立刻看见手机上的变化。</p><p>但是如果一个组件在不同的条件下外观也不一样呢？例如，一个按钮组件可能会有一个默认的样式，但是还会有一个按下的样式，一个正在执行任务的样式，一个已经完成任务的样式，等等。</p><p>为了避免每次都要和app进行交互，我们创建了一个可视化调试的<code>Playground</code>组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/setup.js */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Playground</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">const</span> content = [];</span><br><span class="line">    <span class="keyword">const</span> define = <span class="function">(<span class="params">name: string, render: <span class="built_in">Function</span></span>) =&gt;</span> &#123;</span><br><span class="line">      content.push(&lt;Example key=&#123;name&#125; render=&#123;render&#125; /&gt;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var AddToScheduleButton = require('./tabs/schedule/AddToScheduleButton');</span><br><span class="line">    AddToScheduleButton.__cards__(define);</span><br><span class="line">    this.state = &#123;content&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View style=&#123;&#123;paddingTop: 20&#125;&#125;&gt;</span><br><span class="line">        &#123;this.state.content&#125;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的创建了一个空的view，这个view可以用来在加载的时候不加载真实的app而是置换成别的view。当我们将这个和一个UI组件中的一些示例定义组合在一起，例如 <code>AddToScheduleButton.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/tabs/schedule/AddToScheduleButton.js */</span></span><br><span class="line"><span class="built_in">module</span>.exports.__cards__ = <span class="function">(<span class="params">define</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> f;</span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> f &amp;&amp; f(), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  define(<span class="string">'Inactive'</span>, (state = <span class="literal">true</span>, update) =&gt;</span><br><span class="line">    &lt;AddToScheduleButton isAdded=&#123;state&#125; onPress=&#123;() =&gt; update(!state)&#125; /&gt;);</span><br><span class="line"></span><br><span class="line">  define(<span class="string">'Active'</span>, (state = <span class="literal">false</span>, update) =&gt;</span><br><span class="line">    &lt;AddToScheduleButton isAdded=&#123;state&#125; onPress=&#123;() =&gt; update(!state)&#125; /&gt;);</span><br><span class="line"></span><br><span class="line">  define(<span class="string">'Animated'</span>, (state = <span class="literal">false</span>, update) =&gt; &#123;</span><br><span class="line">    f = <span class="function"><span class="params">()</span> =&gt;</span> update(!state);</span><br><span class="line">    <span class="keyword">return</span> &lt;AddToScheduleButton isAdded=&#123;state&#125; /&gt;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以把app变成一个UI预览工具：</p><p><img src="https://raw.githubusercontent.com/facebook/makeitopen/gh-pages/static/images/button-playground.gif" alt="UI preview playground in action with a button and three different states"></p><p>这个例子定义了按钮包括按下和没有按下的状态，而第三个例子在前两个状态下来回切换以展示状态迁移的动画。</p><p>这让我们可以一边和设计师一起合作一边快速的调整基本组件的样式。</p><p>如果你想利用这个，<code>&lt;Playground&gt;</code>组件可以在任意React Native app当中重用。为了启用这个组件，我们所需要做的只是在<code>setup()</code>方法中改变一点点代码来加载<code>&lt;Playground&gt;</code>组件而不是真实的app：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/setup.js */</span></span><br><span class="line">render() &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;<span class="keyword">this</span>.state.store&#125;&gt;</span><br><span class="line">      &lt;F8App /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in js/setup.js */</span></span><br><span class="line">render() &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;<span class="keyword">this</span>.state.store&#125;&gt;</span><br><span class="line">      &lt;Playground /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>&lt;Playground&gt;</code>组件本身可以修改导入到其中的组件。（你想要在Playground中展示哪个组件，在Playground中引入该组件并修改相应的代码即可)</p><h2 id="整合React-Native和数据"><a href="#整合React-Native和数据" class="headerlink" title="整合React Native和数据"></a>整合React Native和数据</h2><p><a href="http://facebook.github.io/react/" target="_blank" rel="noopener">React</a>及其扩展<a href="http://facebook.github.io/react-native/" target="_blank" rel="noopener">React Native</a>, 允许你创建app而不必太担心你的数据从何而来，因此你可以专注在创建app的UI和逻辑部分。</p><p>在第一部分， 我们提到我们是如何选用Parse服务端来实际存储数据的，并且我们将在app当中使用Redux来处理数据。在这一部分，我们将解释Redux是如何在React Native app里工作的，以及连接Parse服务端的简单过程。</p><p>在我们讨论Redux之前，让我们先从React是如何和数据进行整合进而诞生了Redux开始。</p><h3 id="首先，React-app是如何与数据交互的？"><a href="#首先，React-app是如何与数据交互的？" class="headerlink" title="首先，React app是如何与数据交互的？"></a>首先，React app是如何与数据交互的？</h3><p>React通常被提到是作为MVC架构中的’View’层，但它远比’View’层要精妙的多 － React本质上重新审视了MVC总体的模式。</p><p>让我们首先回顾一下MVC架构的思路：</p><ul><li>model就是数据。</li><li>view是数据如何在app当中呈现。</li><li>controller提供了在app当中处理数据的逻辑。</li></ul><p>React让你创建了多个组件来组成一个view，但是每个组件也可以处理一个controller可能会提供的逻辑。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">// 渲染已有数据的视图，</span></span><br><span class="line">        <span class="comment">// 可能是一个潜在的form，通过handleSubmit方法触发数据改变</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleSubmit(e) &#123;</span><br><span class="line">        <span class="comment">// 修改数据，类似于一个controller的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个React app中的每个组件都会知晓两种不同类型的数据，这两种类型的数据具有不同的角色：</p><ul><li><code>props</code>是当一个组件被创建时传递进来的数据，通常被用作组件的选项。如果你有一个按钮组件，按钮的文本可以作为一个<code>prop</code>。一个组件不可以改变自己的<code>props</code>(也就是说，它们是不可变的)。</li><li><code>state</code>是组件可以随时改变的数据。如果上面例子中的按钮是一个登录/登出按钮，那面<code>state</code>可能会存储用户现在的登录状态，按钮能够访问这个state，并且如果点击了按钮可以修改state以改变它们的状态。</li></ul><p>为了让React app减少重复，<code>state</code>通常被app组件层级中的最高级别的父组件所拥有 － 我们在教程的其它部分指代为<strong>容器组件</strong>。换句话说，在上面的例子中，你不会把state放在按钮组件中，而是把它放在按钮组件的父元素中，然后用<code>props</code>来传递<code>state</code>中相关的部分给子组件。正因为如此，在任何app当中，数据只能单向的向下传递，保证了开发快速及模块化。</p><p>如果你想的话，你可以进一步阅读React网站上的<a href="https://facebook.github.io/react/docs/thinking-in-react.html" target="_blank" rel="noopener">Thinkng in React</a>指南来理解这些理论背后的原因和想法。</p><h3 id="保存状态"><a href="#保存状态" class="headerlink" title="保存状态"></a>保存状态</h3><p>为了进一步解释React app当中使用数据相关的技术，Facebook提出了<a href="(https://facebook.github.io/flux/docs/overview.html">Flux架构</a>，它是最初用来在app里实现的设计模式，并不是一个可以使用的实际框架。我们不在app当中使用<a href="https://github.com/facebook/flux" target="_blank" rel="noopener">Flux库</a>，但是我们所使用的Redux框架是从Flux架构演化而来，所以让我们先来探究一下Flux。</p><p>引入Stores的概念、app的<code>state</code>对象的容器和实时改变<code>state</code>的新工作流程扩大了React的数据关系：</p><ul><li>Flux app当中的每个<strong>Store</strong>有一个在Dispatcher中注册的回调函数。</li><li><strong>Views</strong>(通常来说是React组件)可以触发<strong>Actions</strong> - 通常是一个包含了一大堆代表已发生事情的数据(比如，它可能包括刚刚在app表单当中输入的新数据)以及<strong>action type(动作类型)</strong> - 本质上是一个描述所执行动作的类型的常量。</li><li>Action会被发送至<strong>Dispatcher</strong>.</li><li>Dispatcher将这个Action传播给所有注册的Store回调函数。</li><li>如果Store可以判断它被这个Action所影响（因为动作类型是和数据相关的），Store会更新自己，因此也包括所包含的<code>state</code>。一旦更新完成，它会发送一个change事件。</li><li><strong>Controller Views</strong>(我们之前提过的容器组件的一个好听的名字) 是特殊的视图，它会监听这些change事件，当它们捕获到一个change事件时，它们就知道应该去获取新的Store数据。</li><li>一旦获取新数据完成，它们会用新数据调用<code>setState()</code>方法，引起View内部组件的重新渲染。</li></ul><p>你可以看到Flux是怎么帮助保证在React app内部的单向数据流动，并且使得React的数据部分变得更优雅更结构化。</p><p>我们并不直接使用Flux，因此我们不会详细介绍这一部分，但是如果你想了解更多，可以去阅读Flux网站上的<a href="https://facebook.github.io/flux/docs/todo-list.html" target="_blank" rel="noopener">教程</a>。</p><p>那么我们app当中实际使用的框架Redux是怎么和Flux联系在一起的？</p><h3 id="从Flux到Redux"><a href="#从Flux到Redux" class="headerlink" title="从Flux到Redux"></a>从Flux到Redux</h3><p>Redux是Flux架构的一种实现，但它也简化了框架，并且有<a href="https://github.com/reactjs/react-redux" target="_blank" rel="noopener">React-Redux包</a>提供的官方绑定工具来帮助更简单的整合React app和Redux。</p><p>Redux中并没有调度器(Dispatcher)，并且整个app当中只有一个<code>state</code>的Store。</p><p>Redux中的数据流动是怎样进行的？下面我们会详细讲述，但首先有这些基础概念：</p><ul><li>React组件会触发Actions，比如通过点击一个按钮。</li><li>Actions是通过<code>dispatch</code>方法发送给Store的对象（包含一个<code>type</code>标签和一些其它相关数据）。</li><li>Stores将Action的内容同当前的<code>state</code>树(<a href="https://egghead.io/lessons/javascript-redux-the-single-immutable-state-tree" target="_blank" rel="noopener"><code>state</code>树</a>是一个单一的以独特的结构包含所有<code>state</code>数据的对象)一同发送给Reducers。</li><li>Reducer是一个<a href="http://redux.js.org/docs/basics/Reducers.html#handling-actions" target="_blank" rel="noopener">单纯的方法</a>，获取之前的<code>state</code>和Action，然后根据Action所指示的改变返回一个新的<code>state</code>。一个Redux app可以有一个Reducer, 但是大多数app会包含若干个Reducer，每一个处理一部分<code>state</code>(我们将会在下面进一步介绍).</li><li>Store接收新的<code>state</code>，并且替换掉当前的state.当我们说<code>state</code>被<em>更新</em>时并没有什么值得提的，它就是被<em>替换了</em>。</li><li>当<code>state</code>改变时，Store会触发一个<a href="http://redux.js.org/docs/api/Store.html#subscribe" target="_blank" rel="noopener">change事件</a>。</li><li>任何<a href="http://redux.js.org/docs/api/Store.html#subscribe" target="_blank" rel="noopener">订阅了change事件</a>的React组件会调用方法<a href="http://redux.js.org/docs/api/Store.html#getState" target="_blank" rel="noopener">从Store里获取最新的<code>state</code></a>.</li><li>新的<code>state</code>会更新这些组件。</li></ul><p>这个流程可以简单的总结为下图：</p><p><img src="https://raw.githubusercontent.com/facebook/makeitopen/gh-pages/static/images/redux_flowchart.png" alt="Redux data flow as described above"></p><p>你可以看到数据是如何清晰的顺着单向路径流转，没有交叉重叠、反向流动。这也展示了app可以怎样清晰的将各个部分分隔开 － Store仅仅关心怎么持有<code>state</code>; Views中的组件仅仅关心展示数据及触发Action; Actions仅仅关注如何指示<code>state</code>中的一部分发生了改变以及包括相关的数据; Reducers仅仅关心怎么将旧的<code>state</code>和可变的Actions转变成新的<code>state</code>。当阅读并理解代码时会发现每部分都很模块化，优雅，并且有一个清晰的目的。</p><p>同Flux相比还有一些其它优点：</p><ul><li>Actions是唯一触发<code>state</code>改变的方式，这将状态改变的过程集中管理，并与UI组件相剥离，并且由于它们会在Reducer中恰当的排序执行，从而能够防止竞态条件。</li><li><code>state</code>实质上是不可变的，从而会创建了一系列的<code>state</code>，其中每个state都代表了一次独立的改变。这会提供给你一个app中清晰容易追溯的<code>state</code>历史记录。</li></ul><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>我们已经很抽象的讲述了数据流，那么现在让我们看一看我们的React app是如何将所有这些拼凑到一起使用的。</p><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><p><a href="http://redux.js.org/docs/basics/Store.html" target="_blank" rel="noopener">Redux文档</a>非常详细的解释了如何创建一个简单的Store，因此我们假设你已经阅读过了这些基本内容，略过这部分内容直接跳到我们的Store中的一些特色。</p><h5 id="Store的离线同步"><a href="#Store的离线同步" class="headerlink" title="Store的离线同步"></a>Store的离线同步</h5><p>我们之前已经提到过数据离线存储的需求，从而我们的app可以在弱信号或者无信号的条件(这在技术会议当中十分重要！)下操作。所幸由于我们使用Redux，有一个我们可以在app当中使用的非常简单的模块：<a href="https://www.npmjs.com/package/redux-persist" target="_blank" rel="noopener">Redux Persist</a>。</p><p>我们还在Store中使用了一个叫做<a href="http://redux.js.org/docs/advanced/Middleware.html" target="_blank" rel="noopener"><strong>Middleware</strong></a>的东西 － 我们将会在测试章节中介绍更多关于中间件的内容，但是简单来说，中间件允许你在Action被分派和它到达Reducer这一过程中间加入额外的逻辑(这对于日志、崩溃记录、异步API等等之类事情很有用)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* js/store/configureStore.js */</span></span><br><span class="line"><span class="keyword">var</span> createF8Store = applyMiddleware(...)(createStore);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">onComplete: ?(</span>) =&gt; <span class="title">void</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = autoRehydrate()(createF8Store)(reducers);</span><br><span class="line">  persistStore(store, &#123;<span class="attr">storage</span>: AsyncStorage&#125;, onComplete);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这的嵌套函数语法可能会有一点令人困惑（有些函数返回了一个需要将另一个函数作为参数的函数）。稍微将代码扩展一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* js/store/configureStore.js */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> middlewareWrapper = applyMiddleware(...);</span><br><span class="line"><span class="keyword">var</span> createF8Store = middlewareWrapper(createStore(reducers));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">onComplete: ?(</span>) =&gt; <span class="title">void</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> rehydrator = autoRehydrate();</span><br><span class="line">  <span class="keyword">const</span> store = rehydrator(createF8Store);</span><br><span class="line">  persistStore(store, &#123;<span class="attr">storage</span>: AsyncStorage&#125;, onComplete);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在第3行使用Redux的<code>applyMiddleware()</code>方法(如果你想了解更多内容，阅读<a href="http://redux.js.org/docs/api/applyMiddleware.html" target="_blank" rel="noopener">Redux <code>applyMiddleware</code>文档</a>)激活了中间件, 这个方法返回了一个可以增强Store对象的函数。</p><p>然后在第4行我们将Redux的<a href="http://redux.js.org/docs/api/createStore.html" target="_blank" rel="noopener"><code>createStore()</code></a>方法(app当中的所有Reducers作为参数)包在这个增强的函数里。<code>createStore()</code>返回app的Store对象，<code>middlewareWrapper()</code>用中间件增强了这个对象，并且将增强后的结果Store对象存储在<code>createF8Store</code>中。</p><p>然后我们对Store对象进行了稍许配置。<a href="https://github.com/rt2zz/redux-persist#autorehydrate" target="_blank" rel="noopener">Persist的<code>autoRehydrate()</code></a>是另一个Store增强函数(同<code>applyMiddleware()</code>一样返回一个函数)，我们将已有的Store对象传给它(第8行)。<code>autoRehydrate()</code>将之前保存在本地存储的Store对象取出并且自动用<code>state</code>更新现有的Store。</p><p>第9行<a href="https://github.com/rt2zz/redux-persist#persiststorestore-config-callback" target="_blank" rel="noopener">Persist包的<code>persistStore()</code></a>是实际上处理保存app的Store到本地存储的函数(我们已经配置好使用<a href="https://facebook.github.io/react-native/docs/asyncstorage.html" target="_blank" rel="noopener">React Native内建的AsyncStorage系统</a>)。这部分简单的<code>autoRehydrate()</code>和<code>persistStore()</code>代码是我们app中需要的所有启用离线同步的代码。</p><p>现在，无论何时app丢失了互联网连接，Store最近的一次拷贝仍然会在本地存储里等待着，从用户层面来看，app仍然正常的运行。</p><p>更多信息可以阅读<a href="https://www.npmjs.com/package/redux-persist#basic-usage" target="_blank" rel="noopener">Redux Persist如何工作的技术细节</a>，不过实质上我们已经完成了创建Store的工作。</p><h5 id="Reducers"><a href="#Reducers" class="headerlink" title="Reducers"></a>Reducers</h5><p> 在之前解释Redux的过程中，我们提到引入了一个Reducer对象。然而每个app当中可以有多个Reducers，每个关注<code>state</code>的不同部分。举个简单的例子，在一个评论app当中，你可以有一个与登录状态有关的reducer以及其它和实际评论数据有关的reducers。</p><p> 在我们的F8 app当中，我们将reducers存储在<code>js/reducers/</code>中。以下是摘抄<code>user.js</code>中的一部分:</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* js/reducers/user.js */</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">import</span> type &#123;Action&#125; <span class="keyword">from</span> <span class="string">'../actions/types'</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  isLoggedIn: <span class="literal">false</span>,</span><br><span class="line">  hasSkippedLogin: <span class="literal">false</span>,</span><br><span class="line">  sharedSchedule: <span class="literal">null</span>,</span><br><span class="line">  id: <span class="literal">null</span>,</span><br><span class="line">  name: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">user</span>(<span class="params">state: State = initialState, action: Action</span>): <span class="title">State</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">'LOGGED_IN'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;id, name, sharedSchedule&#125; = action.data;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      isLoggedIn: <span class="literal">true</span>,</span><br><span class="line">      hasSkippedLogin: <span class="literal">false</span>,</span><br><span class="line">      sharedSchedule,</span><br><span class="line">      id,</span><br><span class="line">      name,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">'SKIPPED_LOGIN'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      isLoggedIn: <span class="literal">false</span>,</span><br><span class="line">      hasSkippedLogin: <span class="literal">true</span>,</span><br><span class="line">      sharedSchedule: <span class="literal">null</span>,</span><br><span class="line">      id: <span class="literal">null</span>,</span><br><span class="line">      name: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">'LOGGED_OUT'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> initialState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">'SET_SHARING'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...state,</span><br><span class="line">      sharedSchedule: action.enabled,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = user;</span><br></pre></td></tr></table></figure><p>可以看出，这个reducer和登录/登出操作以及用户特定的选项改变相关。让我们一一来看。</p><p>注意：我们在第16行使用了ES2015的<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">解构赋值</a>语法，会将<code>action.data</code>里的每个值赋值给左边的各个变量。</p><h5 id="1-初始状态"><a href="#1-初始状态" class="headerlink" title="1.初始状态"></a>1.初始状态</h5><p>一开始我们遵循<a href="http://flowtype.org/docs/type-aliases.html" target="_blank" rel="noopener">Flow的类型声明</a>（我们会在测试React Native app当中详细解释）定义了初始状态（第6行），<code>initialState</code>定义了app第一次加载时需要的值，或者在任何之前同步的Store ‘rehydrated’之前需要的值，这个initialState只定义了<code>state</code>树中这个reducer需要处理的那部分。</p><h5 id="2-Reducer-方法"><a href="#2-Reducer-方法" class="headerlink" title="2.Reducer 方法"></a>2.Reducer 方法</h5><p>然后，我们编写了Reducer的主要部分（第14行至第50行），它实际上非常简单。<code>state</code>和一个Action作为参数，<code>initialState</code>作为<code>state</code>的默认值。然后我们根据接收到的Action(有一个’type’标签指定这个Action的类型)，返回一个新的改变过的<code>state</code>。</p><p>举个例子，如果分配到了<code>LOGGED_OUT</code> Action（第37行）(因为用户点击了一个登出按钮)，我们将<code>state</code>树的这部分重置为<code>initialState</code>。如果<code>LOGGED_IN</code> Action出现了（第15行），app会用Action中剩余的数据负载，返回一个新的<code>state</code>，<code>state</code>反应既包括标准值的改变比如<code>isLoggedIn</code>，又包括了来自于用户输入数据的变化比如<code>name</code>。</p><p>还有一个值得我们注意，就是<code>SET_SHARING</code> Action类型（第40行）。因为它用到了一个很有趣的<code>...state</code>标记。它(也被叫做<a href="http://redux.js.org/docs/recipes/UsingObjectSpreadOperator.html" target="_blank" rel="noopener">对象展开操作符</a>)比<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener"><code>Object.assign()</code></a>更简洁更具可读性，它是包含在<a href="https://facebook.github.io/react-native/docs/javascript-environment.html#javascript-syntax-transformers" target="_blank" rel="noopener">React中的Javascript语法转换器</a>的一部分。它实际上做的是创建了一个对象包括现有<code>state</code>的拷贝同时更新了<code>sharedSchedule</code>的值。</p><p>你可以看到这个Reducer结构是有多么的简洁并有可读性 － 定义了一个<code>initialState</code>、创建了一个把<code>state</code>和Action作为参数并返回一个新的<code>state</code>的方法，仅此而已。</p><p>我们这个方法里其它事情都没做因为关于reducers有一条很重要的规则，我们一字不差的从<a href="http://redux.js.org/docs/basics/Reducers.html#handling-actions" target="_blank" rel="noopener">Redux文档</a>里引用过来：</p><blockquote><p>记住reducer必须保持纯粹。给定同样的参数，它应当计算下一个状态并将其返回。没有任何意外，没有任何副作用，没有任何API的调用，没有任何对对象的修改。仅仅是一个计算。</p></blockquote><p>另外值得注意的一点：看看<code>js/reducers/notifications.js</code>，也引用了<code>LOGGED_OUT</code>类型的Action；我们之前提到过，但是还得再重复一次 － 一个Action被分配以后总会调用每一个reducer，因此多个reducers可能会根据同一个Action更新<code>state</code>树的不同部分。</p><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>让我们仔细看看登录相关的Action，看它在代码中是处于什么样的位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/actions/login.js */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skipLogin</span>(<span class="params"></span>): <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'SKIPPED_LOGIN'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个非常简单的Action生成器（这个生成器函数返回的对象实际上就是Action），但你也能看见一个Action的基本结构 － 每个Action都可以是一个很简单的包括自定义<code>type</code>标签的对象。reducers可以用这个<code>type</code>来执行<code>state</code>的更新。</p><p>我们也可以在<code>type</code>之外加上一些数据负载：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/actions/filter.js */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyTopicsFilter</span>(<span class="params">topics</span>): <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'APPLY_TOPICS_FILTER'</span>,</span><br><span class="line">    topics: topics,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的Action生成器接受一个参数，并把它插入到Action对象中。</p><p>我们也有一些Action生成器在返回Action对象的同时执行一些额外的逻辑。在这个例子里，我们也使用一个自定义的Action，叫做ThunkAction(<a href="http://redux.js.org/docs/recipes/ReducingBoilerplate.html" target="_blank" rel="noopener">Redux推荐创建类似这种的函数来减少样板代码</a>) － 这种特殊类型的Action生成器返回的不是Action而是一个函数。这种情况下，<code>logOut</code>Action生成器返回一个执行注销相关逻辑再分配Action的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/actions/login.js */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logOut</span>(<span class="params"></span>): <span class="title">ThunkAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    Parse.User.logOut();</span><br><span class="line">    FacebookSDK.logout();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dispatch(&#123;</span><br><span class="line">      type: <span class="string">'LOGGED_OUT'</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(注意我们在这个例子中使用了<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数语法</a>)</p><h5 id="异步Actions"><a href="#异步Actions" class="headerlink" title="异步Actions"></a>异步Actions</h5><p>假如你需要和API交互，那你会需要一些异步的Actions生成器。Redux本身有一个<a href="http://redux.js.org/docs/advanced/AsyncActions.html" target="_blank" rel="noopener">相当复杂的方式来实现异步</a>，但由于我们在使用React Native，我们可以使用<a href="https://facebook.github.io/react-native/docs/javascript-environment.html#javascript-syntax-transformers" target="_blank" rel="noopener">ES7的await功能</a>来简化这一过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/actions/config.js */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadConfig</span>(<span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">Action</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> config = <span class="keyword">await</span> Parse.Config.get();</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'LOADED_CONFIG'</span>,</span><br><span class="line">    config,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们访问了Parse的API来获取一些app的配置数据。任何一个类似的访问网络资源的API都会花费一定的时间。Action生成器首先等待API调用的结果(不会阻塞Javascript线程)，然后一旦数据获取到了就会返回Action对象(将API数据放在负载里)，而不是将Action立刻分配。</p><p>像这样异步调用的一个好处是当我们异步等待<code>Parse.Config</code>调用的结果时，其它的一些异步操作也可以同时进行，因此我们可以将许多操作组合在一起，自动提高操作的效率。</p><h3 id="绑定组件"><a href="#绑定组件" class="headerlink" title="绑定组件"></a>绑定组件</h3><p>现在我们在app的setup函数中将Redux的逻辑和React联系在一起：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/setup.js */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params"></span>): <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... other setup logic</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Root</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        store: configureStore(),</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Provider store=&#123;<span class="keyword">this</span>.state.store&#125;&gt;</span><br><span class="line">          &lt;F8App /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return Root;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>我们用的是官方的<a href="https://github.com/reactjs/react-redux" target="_blank" rel="noopener">React-Redux绑定库</a>，因此我们可以使用内置的<a href="http://redux.js.org/docs/basics/UsageWithReact.html#passing-the-store" target="_blank" rel="noopener"><code>&lt;Provider&gt;</code>组件</a>(如第14行所示)。Provider允许我们将已创建好的Store连接到任意我们想要连接的组件上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/F8App.js */</span></span><br><span class="line"><span class="keyword">var</span> F8App = React.createClass(&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    notifications: state.notifications,</span><br><span class="line">    isLoggedIn: state.user.isLoggedIn || state.user.hasSkippedLogin,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = connect(select)(F8App);</span><br></pre></td></tr></table></figure><p>上面我们展示了<code>&lt;F8App&gt;</code>组件中的一部分代码 － 整个app的父组件。</p><p>第6行的函数是用来获取Redux Store，然后从中获取一些数据，再把它插入到我们<code>&lt;F8App&gt;</code>组件的<code>props</code>中。这种情况下，我们想要将通知相关的数据和用户的登录状态作为组件的<code>props</code>，并且将它们与Store里的任何变化同步。</p><p>我们可以使用React-Redux的<a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" target="_blank" rel="noopener"><code>connect()</code>函数</a>来完成这些 － <code>connect()</code>有一个叫做<a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#arguments" target="_blank" rel="noopener"><code>mapStateToProps</code></a>的参数，这个参数会带有另一个函数作为参数并且只要Store一有更新，那个函数就会被调用。</p><p>于是当我们app的Store更新时，<code>select()</code>(第6行)会被调用，新<code>state</code>会作为被调用的参数。<code>select()</code>返回一个包含我们想要从新<code>state</code>中获得的数据(这个例子中是<code>notifications</code>和<code>isLoggedIn</code>)，然后第13行调用的<code>connect()</code>会将这个数据融合进<code>&lt;F8App&gt;</code>组件的<code>props</code>中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/F8App.js */</span></span><br><span class="line"><span class="keyword">var</span> F8App = React.createClass(&#123;</span><br><span class="line">  ...</span><br><span class="line">  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.notifications.enabled &amp;&amp; !<span class="keyword">this</span>.props.notifications.registered) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们现在有一个会根据新<code>state</code>数据而更新的<code>&lt;F8App&gt;</code>组件，它通过<code>select()</code>函数订阅了这些新<code>state</code>数据，同时它也能够通过自己的props来访问这些数据(如第6行所示)。但是我们怎么分配组件中的产生的Action呢？</p><h5 id="分配组件中产生的Action"><a href="#分配组件中产生的Action" class="headerlink" title="分配组件中产生的Action"></a>分配组件中产生的Action</h5><p>我们来看看<code>&lt;GeneralScheduleView&gt;</code>的相关部分来了解我们是怎么将Action和组件联系在一起的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/tabs/schedule/GeneralScheduleView.js */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneralScheduleView</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  props: Props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.renderStickyHeader = <span class="keyword">this</span>.renderStickyHeader.bind(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.switchDay = <span class="keyword">this</span>.switchDay.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ListContainer</span><br><span class="line">        title=<span class="string">"Schedule"</span></span><br><span class="line">        backgroundImage=&#123;<span class="built_in">require</span>(<span class="string">'./img/schedule-background.png'</span>)&#125;</span><br><span class="line">        backgroundShift=&#123;<span class="keyword">this</span>.props.day - <span class="number">1</span>&#125;</span><br><span class="line">        backgroundColor=&#123;<span class="string">'#5597B8'</span>&#125;</span><br><span class="line">        data=&#123;<span class="keyword">this</span>.props.data&#125;</span><br><span class="line">        renderStickyHeader=&#123;<span class="keyword">this</span>.renderStickyHeader&#125;</span><br><span class="line">        ...</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  renderStickyHeader() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &lt;F8SegmentedControl</span><br><span class="line">          values=&#123;[<span class="string">'Day 1'</span>, <span class="string">'Day 2'</span>]&#125;</span><br><span class="line">          selectedIndex=&#123;<span class="keyword">this</span>.props.day - <span class="number">1</span>&#125;</span><br><span class="line">          selectionColor=<span class="string">"#51CDDA"</span></span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.switchDay&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        ...</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  ...</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  switchDay(page) &#123;</span></span><br><span class="line"><span class="regexp">    this.props.switchDay(page + 1);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">module.exports = GeneralScheduleView;</span></span><br></pre></td></tr></table></figure><p>同样，这部分代码为了展示已经简化了很大一部分内容，不过我们可以添加并且修改第49行的代码来将这个<a href="">容器组件</a>和Redux store联系在一起：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/tabs/schedule/GeneralScheduleView.js */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    day: store.navigation.day,</span><br><span class="line">    data: data(store),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">actions</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    switchDay: <span class="function">(<span class="params">day</span>) =&gt;</span> dispatch(switchDay(day)),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = connect(select, actions)(GeneralScheduleView);</span><br></pre></td></tr></table></figure><p>这次有一点不同 － 我们提供了React-Redux的<a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" target="_blank" rel="noopener"><code>connect()</code>函数</a>的一个可选参数，<a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#arguments" target="_blank" rel="noopener"><code>mapDispatchToProps</code></a>。简单来说，这样会将<code>actions()</code>中的action生成器融合进组件的props中，同时将它们包在<code>dispatch()</code>里好让它们立刻就分配一个Action。</p><h5 id="它是如何工作的"><a href="#它是如何工作的" class="headerlink" title="它是如何工作的"></a>它是如何工作的</h5><p>让我们看看实际上的组件长什么样子：</p><p><img src="https://raw.githubusercontent.com/facebook/makeitopen/gh-pages/static/images/iOS vs Android Segmented Controls@3x.png" alt="Screenshot of segmented controls"></p><p>点击’Day 1’会触发一个<code>renderStickyHeader()</code>中的<code>onChange</code>事件，然后这个组件里的<code>switchDay()</code>函数会被调用，这个函数本身会分配<code>this.props.switchDay()</code>这个action生成器。在我们的一个Actions文件中，我们可以看见这个action生成器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/actions/navigation.js */</span></span><br><span class="line">  switchDay: (day): <span class="function"><span class="params">Action</span> =&gt;</span> (&#123;</span><br><span class="line">    type: <span class="string">'SWITCH_DAY'</span>,</span><br><span class="line">    day,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>在导航Reducer里可以发现这会用修改过的<code>day</code>值生成一个新的<code>state</code>树：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/reducers/navigation.js */</span></span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">'SWITCH_DAY'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;...state, <span class="attr">day</span>: action.day&#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个Reducer(以及其它任何正观测<code>SWITCH_DAY</code>Action的Reducer)返回一个新的<code>state</code>给Store，Store会据此更新自身并发送一个change事件。</p><p>并且由于将Redux Store和<code>&lt;GeneralScheduleView&gt;</code>连接在一起，这个组件也订阅了Store中<code>state</code>的改变，组件会用新的改变过的<code>day</code>值刷新，展示第一天的日程安排。</p><h3 id="Parse服务端会发生什么呢"><a href="#Parse服务端会发生什么呢" class="headerlink" title="Parse服务端会发生什么呢"></a>Parse服务端会发生什么呢</h3><p>到目前为止你应该已经消化了许多的新知识，不过还是让我们快速的过一下我们是怎么将React Native app和Parse服务器的数据后端连接在一起的，以及它相关的API：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parse.initialize(</span><br><span class="line">  <span class="string">'PARSE_APP_ID'</span>,</span><br><span class="line">);</span><br><span class="line">Parse.serverURL = <span class="string">'http://exampleparseserver.com:1337/parse'</span></span><br></pre></td></tr></table></figure><p>仅此而已，我们在React Native内部就和Parse API连接上了。</p><p>当然，由于我们使用了<a href="https://github.com/ParsePlatform/ParseReact" target="_blank" rel="noopener">Parse+React</a>的SDK(其中的<code>parse/react-native</code>包)，我们相当简单就能访问到SDK了。</p><h5 id="Parse和Action"><a href="#Parse和Action" class="headerlink" title="Parse和Action"></a>Parse和Action</h5><p>当然，我们想要能够做一些查询(比如在Action里面)…许多的查询。这些action生成器并没有什么特殊的；它们同我们之前提到的异步Actions一样。然而，由于需要如此多的简单Parse API请求来初始化app，我们想要稍微减少一点样板代码。在我们的基础Action文件中，我们创建了一个基础action生成器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/actions/parse.js */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadParseQuery</span>(<span class="params">type: string, query: Parse.Query</span>): <span class="title">ThunkAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> query.find(&#123;</span><br><span class="line">      success: <span class="function">(<span class="params">list</span>) =&gt;</span> dispatch((&#123;type, list&#125;: any)),</span><br><span class="line">      error: logError,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以很简单的重用很多次：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loadMaps: (): <span class="function"><span class="params">ThunkAction</span> =&gt;</span></span><br><span class="line">  loadParseQuery(<span class="string">'LOADED_MAPS'</span>, <span class="keyword">new</span> Parse.Query(Maps)),</span><br></pre></td></tr></table></figure><p><code>loadMaps()</code>是一个action生成器，它会运行简单Parse请求所有存储的地图数据，然后当请求完成时在Action的负载里传递它。<code>loadMaps()</code>和一些其它的Parse数据Action在整个app(<code>js/F8App.js</code>)的<code>componentDidMount()</code>函数中被分配，这意味着app会在初次加载时获取所有的Parse数据。</p><h5 id="Parse和Reducer"><a href="#Parse和Reducer" class="headerlink" title="Parse和Reducer"></a>Parse和Reducer</h5><p>我们在Action中已经减少了重复代码，但是我们也想在Reducer中减少样板代码。这些Reducer会接收来自于Action负载的一系列Parse接口数据，并把它们映射到<code>state</code>树中。我们因此为Parse数据创建了一个单一的基础Reducer：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/reducers/createParseReducer.js */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createParseReducer</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  type: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  convert: Convert&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Reducer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">state: ?Array&lt;T&gt;, action: Action</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action.type === type) &#123;</span><br><span class="line">      <span class="comment">// Flow can't guarantee &#123;type, list&#125; is a valid action</span></span><br><span class="line">      <span class="keyword">return</span> (action: any).list.map(convert);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> state || [];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个很简单的Reducer(包含了许多的Flow类型标注)，不过让我们来看看它是如何和基于它的子Reducer一起工作的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/reducers/faqs.js */</span></span><br><span class="line"><span class="keyword">const</span> createParseReducer = <span class="built_in">require</span>(<span class="string">'./createParseReducer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type FAQ = &#123;</span><br><span class="line">  id: string;</span><br><span class="line">  question: string;</span><br><span class="line">  answer: string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fromParseObject</span>(<span class="params">map: Object</span>): <span class="title">FAQ</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    id: map.id,</span><br><span class="line">    question: map.get(<span class="string">'question'</span>),</span><br><span class="line">    answer: map.get(<span class="string">'answer'</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createParseReducer(<span class="string">'LOADED_FAQS'</span>, fromParseObject);</span><br></pre></td></tr></table></figure><p>可以看见避免了每次都重复<code>createParseReducer</code>的部分代码，我们仅仅是简单的传递了一个对象给基础Reducer，这个对象将API数据映射为我们想要的<code>state</code>树。</p><p>现在我们有了一个结构良好并且通俗易懂的数据流，连接到我们的Parse服务端，甚至可以离线同步我们的Store到本地存储中。</p><h2 id="测试React-Native的app"><a href="#测试React-Native的app" class="headerlink" title="测试React Native的app"></a>测试React Native的app</h2><p>在传统的软件开发生命周期中，测试阶段总是被看作是开发快结束时的独立阶段。这在使用了大量开源框架时看起来尤为正确，因为这些框架发布的版本可能并不适用于任何一种测试技术。</p><p>所幸Facebook从创建React Native之初就秉承着持续测试技术的理念。在这部分我们会探究你可以如何使用<a href="http://nuclide.io" target="_blank" rel="noopener">Nuclide</a>，<a href="http://flowtype.org" target="_blank" rel="noopener">Flow</a>和<a href="http://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>来提高你所写代码的质量。</p><h3 id="Flow-防止写坏代码的类型检查"><a href="#Flow-防止写坏代码的类型检查" class="headerlink" title="Flow: 防止写坏代码的类型检查"></a>Flow: 防止写坏代码的类型检查</h3><p><a href="http://flowtype.org" target="_blank" rel="noopener">Flow</a>给Javascript提供了<a href="http://flowtype.org/docs/about-flow.html#_" target="_blank" rel="noopener">静态类型检查</a>，并且以渐进的方式工作，从而允许你可以逐渐的给你的代码增加Flow的特性。这很有用，因为我们可以给特定的部分代码引入类型检查，而不必把整个app都重写以兼容Flow。</p><p>在我们的F8 app当中，我们一开始就决定完整的使用Flow，在任何必要的地方都加上<a href="http://flowtype.org/docs/type-annotations.html#_" target="_blank" rel="noopener">类型标注</a>，让Flow跟随我们的进度同步工作。</p><p>例如，让我们看看在数据教程中我们描述的一个简单Action：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/actions/login.js */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @flow</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skipLogin</span>(<span class="params"></span>): <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'SKIPPED_LOGIN'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在文件头部加上了<code>@flow</code>标记(这会告诉Flow去检查代码)，然后我们用Flow的<a href="http://flowtype.org/docs/type-annotations.html#_" target="_blank" rel="noopener">类型标注</a>来指示<code>skipLogin()</code>返回的一定是<code>Action</code>类型。但是这个<code>Action</code>类型并不是React Native或者Redux内置的，所以我们需要自己定义一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/actions/types.js */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type Action =</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">'LOADED_ABOUT'</span>, <span class="attr">list</span>: <span class="built_in">Array</span>&lt;ParseObject&gt; &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'LOADED_NOTIFICATIONS'</span>, <span class="attr">list</span>: <span class="built_in">Array</span>&lt;ParseObject&gt; &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'LOADED_MAPS'</span>, <span class="attr">list</span>: <span class="built_in">Array</span>&lt;ParseObject&gt; &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'LOADED_FRIENDS_SCHEDULES'</span>, <span class="attr">list</span>: <span class="built_in">Array</span>&lt;&#123; <span class="attr">id</span>: string; name: string; schedule: &#123;[key: string]: boolean&#125;; &#125;&gt; &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'LOADED_CONFIG'</span>, <span class="attr">config</span>: ParseObject &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'LOADED_SESSIONS'</span>, <span class="attr">list</span>: <span class="built_in">Array</span>&lt;ParseObject&gt; &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'LOADED_SURVEYS'</span>, <span class="attr">list</span>: <span class="built_in">Array</span>&lt;<span class="built_in">Object</span>&gt; &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'SUBMITTED_SURVEY_ANSWERS'</span>, <span class="attr">id</span>: string; &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'LOGGED_IN'</span>, <span class="attr">data</span>: &#123; <span class="attr">id</span>: string; name: string; sharedSchedule: ?boolean; &#125; &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'RESTORED_SCHEDULE'</span>, <span class="attr">list</span>: <span class="built_in">Array</span>&lt;ParseObject&gt; &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'SKIPPED_LOGIN'</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'LOGGED_OUT'</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'SESSION_ADDED'</span>, <span class="attr">id</span>: string &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'SESSION_REMOVED'</span>, <span class="attr">id</span>: string &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'SET_SHARING'</span>, <span class="attr">enabled</span>: boolean &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'APPLY_TOPICS_FILTER'</span>, <span class="attr">topics</span>: &#123;[key: string]: boolean&#125; &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'CLEAR_FILTER'</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'SWITCH_DAY'</span>, <span class="attr">day</span>: <span class="number">1</span> | <span class="number">2</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'SWITCH_TAB'</span>, <span class="attr">tab</span>: <span class="string">'schedule'</span> | <span class="string">'my-schedule'</span> | <span class="string">'map'</span> | <span class="string">'notifications'</span> | <span class="string">'info'</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'TURNED_ON_PUSH_NOTIFICATIONS'</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'REGISTERED_PUSH_NOTIFICATIONS'</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'SKIPPED_PUSH_NOTIFICATIONS'</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'RECEIVED_PUSH_NOTIFICATION'</span>, <span class="attr">notification</span>: <span class="built_in">Object</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'SEEN_ALL_NOTIFICATIONS'</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">'RESET_NUXES'</span> &#125;</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure><p>这里我们创建了一个Flow的<a href="http://flowtype.org/docs/type-aliases.html#_" target="_blank" rel="noopener">类型声明</a>，Action类型的任何对象都必须是以下不同类型之一。<code>SKIPPED_LOGIN</code>Action必须只包含它自己的类型标签，相较而言，<code>LOADED_SURVEYS</code> Action必须返回类型标签以及一个列表。我们可以看见相关的Action生成器所做的就是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/actions/surveys.js */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadSurveys</span>(<span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">Action</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> list = <span class="keyword">await</span> Parse.Cloud.run(<span class="string">'surveys'</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'LOADED_SURVEYS'</span>,</span><br><span class="line">    list,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们在app当中使用了大量不同的Action，这种强类型检查让我们知道一些简单的错误比如type标签中的拼写错误，或者是其它一些重要的错误比如数据负载的数据格式错误。</p><p>我们在Reducer中也可以使用同样的强类型检查：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/reducers/surveys.js */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">surveys</span>(<span class="params">state: State = [], action: Action</span>): <span class="title">State</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">'LOADED_SURVEYS'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> action.list;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为参数<code>action</code>是上面提到的<code>Action</code>类型，Reducer函数必须使用合法的<code>action.type</code>。我们也可以使用类型声明来给Reducer的<code>state</code>树定义类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/reducers/user.js */</span></span><br><span class="line"><span class="keyword">export</span> type State = &#123;</span><br><span class="line">  isLoggedIn: boolean;</span><br><span class="line">  hasSkippedLogin: boolean;</span><br><span class="line">  sharedSchedule: ?boolean;</span><br><span class="line">  id: ?string;</span><br><span class="line">  name: ?string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  isLoggedIn: <span class="literal">false</span>,</span><br><span class="line">  hasSkippedLogin: <span class="literal">false</span>,</span><br><span class="line">  sharedSchedule: <span class="literal">null</span>,</span><br><span class="line">  id: <span class="literal">null</span>,</span><br><span class="line">  name: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">user</span>(<span class="params">state: State = initialState, action: Action</span>): <span class="title">State</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在数据教程部分展示了这个<code>initialState</code>对象，你现在可以看看我们是怎么强制<code>state</code>树的这部分必须遵循定义好的Flow类型。如果Reducer接收或者尝试返回任何不符合这个格式的<code>state</code>，我们会遇到一个Flow类型检查的错误。</p><p>记住Flow检查只在编译时进行，React Native的打包器会<a href="https://github.com/facebook/react-native/blob/master/babel-preset/configs/main.js#L32" target="_blank" rel="noopener">自动把这些Flow标记去除</a> － 这意味着在代码中使用Flow不会带来任何的性能损失。</p><p>当然现在我们每次想测试一些代码时还必须手动运行Flow的类型检查(用<a href="http://flowtype.org/docs/cli.html#_" target="_blank" rel="noopener">Flow命令行工具</a>)，不过我们也可以使用Nuclide来在我们<em>写代码</em>时就能进行这类验证。</p><h3 id="Nuclide-React-Native开发环境"><a href="#Nuclide-React-Native开发环境" class="headerlink" title="Nuclide: React Native开发环境"></a>Nuclide: React Native开发环境</h3><p>Nuclide网站包含了一系列为React Native量身定制的特色功能，不过只需要说这是React Native的最佳IDE，同样由Facebook创建React Native的那伙人开发，并且他们每天都使用它来编写Facebook的app。</p><p>集成Flow是我们很感兴趣的一点。下面是我们之前展示的用<code>state</code>类型的Reducer代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (action.type === <span class="string">'SKIPPED_LOGIN'</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    isLoggedIn: <span class="literal">false</span>,</span><br><span class="line">    hasSkippedLogin: <span class="literal">true</span>,</span><br><span class="line">    sharedSchedule: <span class="literal">null</span>,</span><br><span class="line">    id: <span class="literal">null</span>,</span><br><span class="line">    name: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如我们之前所说，我们定义了Reducer函数必须返回的格式，在Nuclide中，我们可以实时看见我们发生的错误：</p><video width="1174" height="1002" autoplay loop><br>  <source src="static/videos/flow.mp4" type="video/mp4"><br>  Your browser does not support the HTML5 video tag.<br></video><p>如果我们留下State类型的任意一部分，快速开发app时很有可能会经常发生一些意外，我们没有返回正确类型的对象时就会得到及时的反馈。</p><p>Nuclide会为我们做所有的相关的Flow类型检查。在代码编写的过程当中，就可以注意到类型错误并改正这些错误，而不用等到app即将开发完毕。</p><p>这看起来可能很不直观，但它确实加速了开发 － 解开无类型的代码谜团很困难，而且在你都已经开发完app时做这些检查会变得混乱无比。</p><h3 id="Jest-无错误修改的单元测试"><a href="#Jest-无错误修改的单元测试" class="headerlink" title="Jest: 无错误修改的单元测试"></a>Jest: 无错误修改的单元测试</h3><p><a href="http://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>提供了Javascript的单元测试框架，并且能很好的在React Native app中工作。</p><p>我们用这些单元测试来保证已经写好的代码没有因为修改而引入bug(也叫做回归测试)。</p><p>比如，我们想要用Jest测试来保证Reducer处理maps的数据能按预期工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">jest.autoMockOff();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Parse = <span class="built_in">require</span>(<span class="string">'parse'</span>);</span><br><span class="line"><span class="keyword">const</span> maps = <span class="built_in">require</span>(<span class="string">'../maps'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'maps reducer'</span>, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'is empty by default'</span>, () =&gt; &#123;</span><br><span class="line">    expect(maps(<span class="literal">undefined</span>, &#123;&#125;)).toEqual([]);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'populates maps from server'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> list = [</span><br><span class="line">      <span class="keyword">new</span> Parse.Object(&#123;<span class="attr">mapTitle</span>: <span class="string">'Day 1'</span>, <span class="attr">mapImage</span>: <span class="keyword">new</span> Parse.File(<span class="string">'1.png'</span>)&#125;),</span><br><span class="line">      <span class="keyword">new</span> Parse.Object(&#123;<span class="attr">mapTitle</span>: <span class="string">'Day 2'</span>, <span class="attr">mapImage</span>: <span class="keyword">new</span> Parse.File(<span class="string">'2.png'</span>)&#125;),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    expect(</span><br><span class="line">      maps([], &#123;<span class="attr">type</span>: <span class="string">'LOADED_MAPS'</span>, list&#125;)</span><br><span class="line">    ).toEqual([&#123;</span><br><span class="line">      id: jasmine.any(<span class="built_in">String</span>),</span><br><span class="line">      title: <span class="string">'Day 1'</span>,</span><br><span class="line">      url: <span class="string">'1.png'</span>,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      id: jasmine.any(<span class="built_in">String</span>),</span><br><span class="line">      title: <span class="string">'Day 2'</span>,</span><br><span class="line">      url: <span class="string">'2.png'</span>,</span><br><span class="line">    &#125;]);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Jest很容易读懂(注意甚至我们的Jest测试都是用Flow标注类型的！)，但是我们会拆开一步一步看。第4行，我们引入了maps的Reducer函数(<code>js/reducers/maps.js</code>)以便它能够在单元测试中直接使用(Reducer函数是<a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">纯粹的函数</a>意味着这很容易做到)。</p><p>第8行的第一个测试保证Reducer函数返回一个空数组，如果你看看<code>js/reducers/maps.js</code>中的Reducer代码，你会发现它没有任何初始state，这也是为什么我们想要从这个单元测试中返回一个空数组。</p><p>第12行的第二个测试保证当map数据从Parse接口获得时能被Reducer函数正确的转换到<code>state</code>树中的正确结构。这个测试中我们使用了模拟数据对象，完全模仿了真实的存储在Parse的数据结构 － 这可以避免任何API连接上的问题而导致测试失败。</p><p>现在我们需要将运行Jest测试作为我们开发工作流中的一部分 － 比如，在提交git之前 － 而且我们可以更自信我们对现有代码的更改不会导致app不能正常运行。</p><p>Redux Reducer维护<code>state</code>树的事实是很重要的，保证了不会引入bug，尤其是维护<code>state</code>而带来的bug很容易就被忽略，因为它们可能不会造成功能不正常，而只是发送错误的数据到Parse服务器上。它们纯粹函数的特性使它们是回归测试的完美候选，因为我们可以更准确的预测它们每次应当怎样执行。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>当你试图定位一个bug时，或者尝试解决bug时，如果有一些好用的调试工具会很有帮助。我们已经描述过我们怎样构建一个可以调试我们app的可视化组件的系统，但是数据方面怎么调试呢？</p><p>我们通过<a href="http://nuclide.io/docs/features/debugger/" target="_blank" rel="noopener">Nuclide</a>使用<a href="https://facebook.github.io/react-native/docs/debugging.html#chrome-developer-tools" target="_blank" rel="noopener">Chrome开发者工具</a>以及<a href="http://fcomb.github.io/redux-logger/" target="_blank" rel="noopener">Redux的日志工具</a>中间件，这个开发者工具提供了带有额外Redux上下文信息的控制台，比如Actions或者Reducers中的<code>state</code>变化：</p><p><img src="https://raw.githubusercontent.com/facebook/makeitopen/gh-pages/static/images/redux_logger.png" alt="Redux Logger Middleware in action with additional console context"></p><p>你可以看看我们是怎样通过<code>configureStore</code>函数来启用这个日志的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from js/store/configureStore.js */</span></span><br><span class="line"><span class="keyword">var</span> createLogger = <span class="built_in">require</span>(<span class="string">'redux-logger'</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> isDebuggingInChrome = __DEV__ &amp;&amp; !!<span class="built_in">window</span>.navigator.userAgent;</span><br><span class="line"><span class="keyword">var</span> logger = createLogger(&#123;</span><br><span class="line">  predicate: <span class="function">(<span class="params">getState, action</span>) =&gt;</span> isDebuggingInChrome,</span><br><span class="line">  collapsed: <span class="literal">true</span>,</span><br><span class="line">  duration: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createF8Store = applyMiddleware(thunk, promise, array, logger)(createStore);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">onComplete: ?(</span>) =&gt; <span class="title">void</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = autoRehydrate()(createF8Store)(reducers);</span><br><span class="line">  persistStore(store, &#123;<span class="attr">storage</span>: AsyncStorage&#125;, onComplete);</span><br><span class="line">  <span class="keyword">if</span> (isDebuggingInChrome) &#123;</span><br><span class="line">    <span class="built_in">window</span>.store = store;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第5行我们<a href="https://github.com/fcomb/redux-logger#options-1" target="_blank" rel="noopener">用一些选项</a>创建了Logger中间件，然后在第10行我们用Redux的<a href="http://redux.js.org/docs/api/applyMiddleware.html" target="_blank" rel="noopener"><code>applyMiddleware()</code>函数</a>来应用这个中间件。我们做这些就可以在控制台里看那些日志条目。</p><p>第4行我们触发了一些额外的调试功能通过使用一个全局变量<code>__DEV__</code>，这让我们通过一个简单的布尔值改变可以自由切换调试模式。它不仅仅决定创建的日志中间件是否记录action(通过<a href="https://github.com/fcomb/redux-logger#predicate--getstate-function-action-object--boolean" target="_blank" rel="noopener"><code>predicate</code>选项</a>)，也在第17行复制了一份现在的Store对象到<a href="http://www.w3schools.com/jsref/obj_window.asp" target="_blank" rel="noopener">Window对象</a>上。避免了每次都要将它附加到Window上，这也使得能够更容易的直接通过浏览器的控制台来访问它。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;App准备阶段&quot;&gt;&lt;a href=&quot;#App准备阶段&quot; class=&quot;headerlink&quot; title=&quot;App准备阶段&quot;&gt;&lt;/a&gt;App准备阶段&lt;/h2&gt;&lt;p&gt;&lt;em&gt;这是在开发F8 2016大会iOS和Android客户端过程中写下的一系列用来介绍React Native和它的开源生态圈的教程.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在第一部分，我们将讲述是如何计划准备这款app的；后续部分我们将分享一些示例代码，讨论如何考虑多平台设计，分析我们app当中的数据层，并且解释我们的测试策略。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MVVM in iOS using ReactiveCocoa</title>
    <link href="http://yiyangest.github.io/2015/10/27/mvvm-in-ios-using-reactivecocoa/"/>
    <id>http://yiyangest.github.io/2015/10/27/mvvm-in-ios-using-reactivecocoa/</id>
    <published>2015-10-26T16:00:00.000Z</published>
    <updated>2018-02-27T10:06:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>传统MVC模式下的iOS开发存在一些问题， ViewController过分臃肿，处理业务逻辑、发送网络请求、响应UI交互、读取持久化数据。为了给ViewController瘦身，通常都会尽量的抽取能够复用的东西单独作为一个模块。尽管如此，ViewController仍然是一个庞大的家伙。</p><p>MVVM可以说是MVC的一个延伸，对于应用程序的结构有了更清晰的划分。</p><ul><li>Model: 仍然同MVC的M，作为实体模型。</li><li>View: 包含视图本身，以及UI交互的处理。UIView及相关的xib/storyboard自然属于这一概念之内，而ViewController事实上也属于这一层，它仅处理和视图、UI相关的逻辑。</li><li>View-Model: 处理原来ViewController留下的一大堆烂摊子，从必要的资源（数据库、网络）中获取原始数据，处理业务逻辑，并将数据通过属性暴露给ViewController，这部分数据仅仅是与视图显示相关的数据。</li></ul><p>总结一下：原来的ViewController中与UI无关的部分，挪到了ViewModel中，由ViewModel来负责给View层提供View所需要的数据，ViewController则负责和UI相关的交互处理。</p><p>在这样架构下的App逻辑里，当ViewModel中的数据发生改变时，我们自然而然的期望视图中相关的UI也发生改变；当我们在输入框中输入文字时，我们也同样期望ViewModel中相关的数据发生改变。</p><p>在我们已知的技术手段里，可以通过写一系列的事件回调(<code>Delegate</code>)、通知处理(<code>Notification</code>)、观察者(<code>KVO</code>)来实现上述目标。当然代价是我们需要小心谨慎的在合适的地方维护好这些实现方法，比如，处理好<code>observer</code>应该在何时被移除，检查是否监听了对的<code>notification name</code>。总而言之，这并不是一件轻松的事儿，它需要有一个非常成熟的整体架构来支持，不然的话可能到处是掉进去出不来的坑。</p><p>ReactiveCocoa可以很好的帮助我们在iOS中实现MVVM这一模式，当然在iOS里实现这一模式，并不是一定需要ReactiveCocoa，但是它绝对能帮助我们节省很多时间。</p><a id="more"></a><h2 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h2><p>ReactiveCocoa是Github开源的一个函数响应式编程框架，其核心思想是响应数据的变化，它用一个信号(<code>RACSignal</code>)的概念来传递数据/状态的变化。以下介绍均基于ReactiveCocoa 2.x版本，在3.x的版本里，有很多API发生了变化。</p><p>在了解它能做些什么之前，我们先来看看在没有它的时候，我们是怎么来实现MVVM的数据流动的。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设我们正在做一个填写信息的表单页面，包括姓名、身份证、车牌等七八项信息，和一个提交表单的按钮，在表单验证没有通过之前是不能点击按钮的。</p><h3 id="开始MVVM"><a href="#开始MVVM" class="headerlink" title="开始MVVM"></a>开始MVVM</h3><p>既然是MVVM，那么先定义一个ViewModel是毫无争议的。这个InfoViewModel里，我们要暴露给UI知道的数据有：姓名、身份证、车牌等。除此之外，各数据项的合规性也是我们需要暴露给UI的。</p><p>与此同时，ViewController已经创建好了一个表单视图，摆好了若干输入框及按钮。回想上文所说的ViewModel负责给View层提供数据，那好办，在ViewController的生命周期中找一个合适的位置，获取ViewModel。并把ViewModel暴露出的数据赋值给输入框、标签、按钮等UI元素。大概是长下面这样：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_textField.text = viewModel.value;</span><br><span class="line">_textField.placeholder = viewModel.placeholder;</span><br><span class="line">_nameLabel.text = viewModel.displayName;</span><br><span class="line">_submitBtn.enabled = viewModel.isValid;</span><br></pre></td></tr></table></figure><p>到目前为止，似乎一切还都很顺利，启动应用程序，界面也会漂亮的展示我们ViewModel中的数据。</p><p>接下来，当输入框中输入文字时，ViewModel中相应的数据应该更新。这个似乎也还好解决，通过UITextField的委托方法，每当有字符变化的时候，更新ViewModel中的数据：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)textFieldDidChange:(<span class="built_in">UITextField</span> *)sender &#123;</span><br><span class="line"><span class="keyword">self</span>.viewModel.value = sender.text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>viewModel中的数据值发生了变化，那应该去重新做一次表单的合规校验，合规的结果应该影响提交按钮的启用状态。于是稍作修改：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)textFieldDidChange:(<span class="built_in">UITextField</span> *)sender &#123;</span><br><span class="line"><span class="keyword">self</span>.viewModel.value = sender.text;</span><br><span class="line"><span class="keyword">self</span>.viewModel.validate();</span><br><span class="line"><span class="keyword">self</span>.submitBtn.enabled = <span class="keyword">self</span>.viewModel.isValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，这里回调只对一个textfield的值变化做了处理，想想我们有七八个textfield的值都需要侦测，去更新ViewModel中的数据，这块代码会变成什么样。</p><p>再接下来，如果业务逻辑中某个地方需要从网络或本地数据库获取数据更新ViewModel里的值，并进一步反映在UI表现上，似乎有点棘手了，要么把ViewController传给ViewModel，让ViewModel在数据变化时去调用ViewController的一个updateUI方法（这显然违背了ViewModel只负责与UI无关的逻辑的原则）；要么把ViewController作为ViewModel的一个delegate；要么给ViewModel暴露一个update的block；要么让ViewModel在数据变化时发一个通知；要么让ViewController KVO ViewModel的属性。</p><p>我们可能费了好一会儿工夫用了上述方法之一解决了问题，新的问题来了。又加了一组输入项及对应的ViewModel的属性，我们可能需要在花上一些时间，把上面的方法再好好检查甚至重新再实现一套。要知道，ViewModel并不像一个Model那样具有那么强的整体性，一个ViewModel可能包含好几个Model的信息，以及好些组合Model而衍生出来的状态数据（比如合规性、网络状态等）；ViewModel中的属性值变化来源是多方面的，可能来自于Rest API，可能来自于本地数据库，可能来自于网络状态，可能来自于内部的逻辑处理。每个可能的角落你都需要顾及到。</p><p>用KVO或许能稍微减轻一些这种负担，不过自己维护一套KVO的机制是需要十分小心的。</p><p>通过种种努力，我们终于完成了这个功能，但是结果是在代码中，我们在大量的地方，都留下了ViewModel与ViewController沟通交互的身影，在viewDidLoad里，在UI控件的回调里，在通知的回调里。将来如果再回头维护修改其中的坑，想想要检查的点散落到处都是。</p><p>而ReactiveCocoa是拯救我们于水火之中的辣个人。</p><h3 id="ReactiveCocoa概念"><a href="#ReactiveCocoa概念" class="headerlink" title="ReactiveCocoa概念"></a>ReactiveCocoa概念</h3><h4 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h4><p>RACSignal是ReactiveCocoa中的核心概念，绝大多数的工作都是围绕RACSignal展开的，它代表一个信号，通常代表了在未来会传递的数据变化。当有数据到来或者某种状态发生改变时，值会在信号上进行传递。订阅者则是负责读取并接收被传递的值。</p><p>信号传递有三种事件：</p><ul><li>next: 代表信号流上传递过来的一个新值。</li><li>error: 代表信号完成前发生了错误。</li><li>completed: 代表信号成功完成了。后续不会再有新的值传递过来。</li></ul><p>一旦发生error，或者completed，就代表此信号已经结束。后续不会再有新的值传递。</p><p>信号可以被串联、组合、映射和过滤，因此运用起来是十分灵活的，不过创建一个信号，看起来并不是那么的直观：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[RACSignal createSignal:^RACDisposable* (<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"><span class="comment">// 发送一个网络请求，或者执行某个操作</span></span><br><span class="line"><span class="comment">// 当请求返回时或者操作完成时，发送字符串hello给订阅者</span></span><br><span class="line">[subscriber sendNext:<span class="string">@"hello"</span>];</span><br><span class="line"><span class="comment">// 返回一个disposable对象，用于在信号销毁时做一些清理及回收工作</span></span><br><span class="line"><span class="comment">//可以是nil，即什么也不做</span></span><br><span class="line"><span class="comment">//return nil;</span></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"><span class="comment">// clean work,例如取消信号源中正在执行的operation。</span></span><br><span class="line">[operation cancel];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>上述代码创建了一个信号，这个信号会监测block中执行的网络请求的返回结果，并将返回结果”hello”传递给订阅者。现在还仅仅是创建了一个信号而已，信号内的动作也就是block中的内容还未被执行。那信号内这个block什么时候会执行呢，当有订阅者订阅了这个信号的时候，就会执行。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">"received: %@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>订阅信号源就像上面这么简单，<code>subscribeNext</code>方法内部创建了一个匿名的订阅者，并且订阅信号源的next事件，在block回调中对每次接收到的值进行处理。</p><p>这样两段代码结合起来，首先创建了一个信号，并且定义好了信号源的内部逻辑，然后订阅了这个信号源，这时信号源的内部逻辑开始执行，并在恰当的时候传送数据，而订阅者的回调方法会接收到这些数据，并做相应的处理。这里面有几点需要特别注意：</p><ul><li>在这种情况下，只有有订阅者订阅了信号源，信号源的内部逻辑才会执行，否则这个信号什么也不会做。这个信号通常也被称为冷信号，它是被动的，只有当你订阅的时候，这个信号才会发布消息。而热信号是主动的，尽管你没有订阅，这个信号仍然在随时推送消息，只是没有人处理这些消息而已。</li><li>当有多个订阅者订阅上述创建的信号时，信号的内部逻辑会被多次执行，每一个订阅者，都会带来一次信号内部逻辑的执行。官方将信号的内部逻辑（也就是创建信号时传入的那个block）称为<code>side effect</code>，对于冷信号来说，每一个订阅者都会触发一次<code>side effect</code>，并且接收到的是各自不同的事件。而热信号即使有多个订阅者，也只会触发一次<code>side effect</code>，并且所有的订阅者接收到的都是同一个事件。</li></ul><p>应用程序当中大部分的逻辑都是围绕着数据及数据的变化展开的，因此在ReactiveCocoa的世界里，大部分的逻辑都是围绕着信号展开的，当有数据到达或者发生变化时，都会通过信号去传递，并通过订阅者的回调事件去做相应的处理。</p><p>信号具有非常多的操作，例如，可以将多个信号组合在一起，将其绑定到一个单独的信号上。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// merge: 多个信号发出的数据都会出现在新信号的流中。</span></span><br><span class="line">RACSignal *merged = [RACSignal merged: @[signal1, signal2]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// combine: 将多个信号整合在一起，每次有信号变化，新信号都将所有信号的值拿过来重新整理成自己的值，再发送出去。</span></span><br><span class="line">RACSignal *combined = [RACSignal combineLatest:@[signal1, signal2] reduce:^(<span class="keyword">id</span> value1, value2)&#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@"</span>, value1, value2];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>信号也可以将另外一个信号的值重新映射成新的值再发送出去：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map: 信号值的映射</span></span><br><span class="line">RACSignal *maped = [RACObserve(<span class="keyword">self</span>, value) map: ^(<span class="built_in">NSString</span> * x)&#123;</span><br><span class="line"><span class="keyword">return</span> [x stringByAppendingString: <span class="string">@"_ map"</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>信号还有很多别的操作，比如filter, skip, takeUntil等，详细的可参见文章下方的各类链接，这里不一一介绍。</p><h4 id="黑魔法：RAC-amp-RACObserve"><a href="#黑魔法：RAC-amp-RACObserve" class="headerlink" title="黑魔法：RAC &amp; RACObserve"></a>黑魔法：RAC &amp; RACObserve</h4><p>上面介绍了ReactiveCocoa中的核心概念信号，而接下来这两个宏<code>RAC</code>和<code>RACObserve</code>则保证了信号在使用过程当中的简洁优雅。</p><p>通过<code>RACObserve</code>可以很方便的创建一个观测某项数据变化的信号，就像下面这样：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个观测viewModel的name属性值变化的信号</span></span><br><span class="line">RACSignal *signal = RACObserve(<span class="keyword">self</span>, viewModel.name);</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span> x)&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"viewmodel name changed to: %@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><code>RACObserve</code>实际上是通过KVO的方法，监测参数中指定的keypath，并当keypath的value发生变化时，信号会传送这个最新值。因此<code>RACObserve</code>的两个参数，是按照KVO来设计的，第一个参数是要监测的对象，第二个参数是该对象中要监测的属性路径(<code>keypath</code>)。当然这也会带来一个KVO的遗留问题，对于监测数组内部的变化（<code>NSMutableArray</code>的<code>addObject</code>和<code>removeObject</code>）没有直接的办法。如果有这种需求，至少有以下两种workaround:</p><ul><li>使用NSArray代替NSMutableArray。</li><li>用mutableArrayValueForKey。</li></ul><p>另一个宏<code>RAC</code>则可以很方便的将信号传递的值绑定到对象的属性上：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将viewModel的name属性值变化的信号绑定到textfield的text上</span></span><br><span class="line"><span class="comment">// 当name值改变时，textfield的text也会随之改变。</span></span><br><span class="line">RAC(_textField, text) = RACObserve(<span class="keyword">self</span>, viewModel.name);</span><br></pre></td></tr></table></figure><p>像上面这样，一行代码即可实现viewmodel中属性和UI的绑定，而这两个宏在背后帮我们做了非常多的事情，帮我们打理好整套KVO的流程、信号发送值、订阅信号并接收值从而改变对象属性。<code>RAC</code>的绑定使得信号每次发出<code>next</code>事件时，都会更改对象的属性值，当信号发出<code>complete</code>或者<code>error</code>标志信号完成时，这个绑定也会自动的销毁，之后对象的属性重新获得自由。</p><h4 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h4><p><code>RACCommand</code>通常用于表示一个动作的执行，而且大多数情况下都是和UI相关的，比如按下一个按钮。在没有进入到ReactiveCocoa的世界之前，我们都是用<code>addTarget:action:forControlEvents</code>来给按钮添加执行动作，这样业务逻辑与UI也会产生一定的交集。而RACCommand可以很好的将业务逻辑与UI交互很好的分离开。</p><p>业务逻辑可以写在ViewModel里，定义成一个RACCommand，而在View层只需要将viewModel中的command绑定给按钮即可。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewModel.m</span></span><br><span class="line"><span class="keyword">self</span>.loginCommand = [[RACComand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</span><br><span class="line"><span class="comment">// request login api</span></span><br><span class="line">RACSignal *loginResultSignal = [APIClient requestLogin];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> loginResultSignal;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>以上代码可以看出，初始化RACCommand时传入了一个block，这个block会在每次command执行时被调用。而这个block有点特殊，它要求返回值是一个信号，这个信号按照业务逻辑的需求，可能是发起一个网络请求，或者是其他的一些操作，可以想象到的是这些操作的结果必然是通过订阅该信号的方式传递出去。</p><p>RACCommand有三个重要的属性（这三个属性都是RACSignal）：</p><ul><li>executing: 表明当前command是否正在执行；</li><li>errors: command执行过程中的错误信息，可以通过<code>[command.errors subscribeNext]</code>来获取订阅错误信息；</li><li>executionSignals：command执行的信号，它实际上是一个信号的信号（signal of signals），当command执行时，会调用初始化传入的block，并将block返回的信号包裹在executionSignal中。executionSignal把block返回的信号转变为热信号，保证command的执行逻辑不会因为有多个订阅者而重复执行。</li></ul><p>因此返回操作数据的信号也就是block中返回的数据，我们需要透过executionSignal才能获取到该信号，如果直接订阅executionSignal拿到的实际上是block返回的信号：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[command.executionSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="comment">// 这里的x是一个信号，并不是数据，实际上这个信号正是block返回的那个信号。</span></span><br><span class="line">[x subscribeNext:^(<span class="keyword">id</span> data)&#123;</span><br><span class="line"><span class="comment">// 这里的data才是真正的数据。</span></span><br><span class="line">&#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>当然，ReactiveCocoa提供了更为方便的办法来应对这种情形：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[command.executionSignals.switchToLatest subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="comment">// 这里x就是返回的数据。</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这里<code>switchToLatest</code>的作用，是获取signal of signals中的子signal。每次当signal of signals发送一个新的signal时，switchToLatest都会将订阅事件转移到这个新的signal上。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *letters = [RACSubject subject];</span><br><span class="line">RACSubject *numbers = [RACSubject subject];</span><br><span class="line">RACSubject *signalOfSignals = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">RACSignal *switched = [signalOfSignals switchToLatest];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Outputs: A B 1 D</span></span><br><span class="line">[switched subscribeNext:^(<span class="built_in">NSString</span> *x) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// signalOfSignals发送了letters信号，因此switchToLatest信号将订阅事件重新订阅到letters上，A和B都会输出。</span></span><br><span class="line">[signalOfSignals sendNext:letters];</span><br><span class="line">[letters sendNext:<span class="string">@"A"</span>];</span><br><span class="line">[letters sendNext:<span class="string">@"B"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送了numbers信号，因此switch信号将订阅事件重新订阅到numbers上，只有numbers发出的数据才会被接收，所以输出1</span></span><br><span class="line">[signalOfSignals sendNext:numbers];</span><br><span class="line">[letters sendNext:<span class="string">@"C"</span>];</span><br><span class="line">[numbers sendNext:<span class="string">@"1"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次发送了letters信号，因此switch信号将订阅事件重新订阅到letters 上，只输出了D</span></span><br><span class="line">[signalOfSignals sendNext:letters];</span><br><span class="line">[numbers sendNext:<span class="string">@"2"</span>];</span><br><span class="line">[letters sendNext:<span class="string">@"D"</span>];</span><br></pre></td></tr></table></figure><p>这种方式也让block中返回的信号发送的数据能够穿透出来，例如一个获取用户信息的command就可以通过这种方式来处理获取到的数据。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[userInfoCommand.executionSignals.switchToLatest subscribNext:^(UserInfo *userInfo) &#123;</span><br><span class="line"><span class="comment">// handle user info</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>RACCommand不光仅仅绑定执行逻辑，它还能绑定按钮的启用状态，可以在command初始化时，传一个返回BOOL数据的信号给command。这样当这个BOOL信号发出YES时，command就可以执行，否则command不能被执行。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// validSignal决定了command是否可执行。</span></span><br><span class="line"><span class="keyword">self</span>.loginCommand = [[RACCommand alloc] initWithWithEnabled:<span class="keyword">self</span>.validSignal signalBlock:^RACSignal *(<span class="keyword">id</span> input)&#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>同时RACCommand还保证了当command执行未结束时，不允许重复执行，也就是一次只能执行一次逻辑。</p><h4 id="RACSubject"><a href="#RACSubject" class="headerlink" title="RACSubject"></a>RACSubject</h4><p>在上面command的例子中，我们已经见识过RACSubject了，RACSubject可以看作是一个高级版的信号，之前在创建信号的例子当中我们可以看到，信号内部定义一系列的逻辑，信号提供了一个<code>[signal subscribeNext]</code>方法来让订阅者订阅事件，不过发送数据却是在信号内部通过<code>[subscriber sendNext]</code>来实现的。信号本身是不具备发送数据功能的。而RACSubject则既可以被订阅，又可以自己发送数据。更为灵活，不过官方并不推荐使用这个对象，尽可能的用其他替代方案来实现。</p><h4 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h4><p>ReactiveCocoa提供了许多的category，来帮助我们更方便的使用RAC中的概念及方法。</p><ul><li><code>textfield.rac_textSignal</code>，当textfield中的值改变时，会触发信号</li><li><code>button.rac_command</code>，给button绑定RACCommand</li><li><code>cell.rac_prepareForReuseSignal</code>，当cell要被重用时，触发信号</li></ul><p>这里只列举了几个，更多的可以参见官方文档。</p><h3 id="使用ReactiveCocoa实践MVVM"><a href="#使用ReactiveCocoa实践MVVM" class="headerlink" title="使用ReactiveCocoa实践MVVM"></a>使用ReactiveCocoa实践MVVM</h3><p>下面我们重新整理一下思路，用ReactiveCocoa来实现上面表单填写的例子。</p><p>表单由七八项需要填写输入的信息组成，每一项要展示出来的样式都比较接近，因此考虑用UITableView来实现。将表单项抽象出一个小的viewModel，由<code>name</code>, <code>displayName</code>, <code>placeholder</code>, <code>validationType</code>, <code>value</code>等属性组成，另外还有一个<code>validSignal</code>信号属性，当value值发生改变时，validSignal会相应的发送value值的合规性（<code>BOOL</code>）。</p><p>表单项对应的cell都会有一个属性formItem，在tableView的datasource里会将表单项数组里的viewModel赋给cell。cell在初始化时就可以对viewModel的属性进行绑定（虽然此时viewModel还是nil）:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TextFieldFormCell.m</span></span><br><span class="line">- (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">RAC(<span class="keyword">self</span>.textField, text) = RACObserve(<span class="keyword">self</span>, formItem.value);</span><br><span class="line">RAC(<span class="keyword">self</span>.textField, placeholder) = RACObserve(<span class="keyword">self</span>, formItem.placeholder);</span><br><span class="line">RAC(<span class="keyword">self</span>.nameLabel, text) = RACObserve(<span class="keyword">self</span>, formItem.displayName);</span><br><span class="line"></span><br><span class="line">RAC(<span class="keyword">self</span>, formItem.value) = <span class="keyword">self</span>.textField.rac_textSignal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)configureWithFormItem: (TextFieldFormItem *)viewModel &#123;</span><br><span class="line"><span class="keyword">this</span>.formItem = viewModel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ViewController.m</span></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">BaseFormItem *item = [<span class="keyword">self</span>.infoVM itemAtIndexPath:indexPath];</span><br><span class="line">FormItemType itemType = item.formItemType;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *identifier = [BaseFormCell cellIdentifierWithFormItemType:itemType];</span><br><span class="line"></span><br><span class="line">BaseFormCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier];</span><br><span class="line">[cell configureWithFormItem:item];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewController会对应一个ViewModel，也就是上例中的self.infoVM。这个infoVM中会定义并管理tableView所需要的数据源数组，并且定义合规信号(<code>RACSignal</code>)以及提交动作(<code>RACCommand</code>)。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InfoViewModel.m</span></span><br><span class="line">- (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">TextFieldFormItem *nameItem = [TextFieldFormItem new];</span><br><span class="line">nameItem.name = <span class="string">@"name"</span>;</span><br><span class="line">nameItem.placeholder = <span class="string">@"请输入姓名"</span>;</span><br><span class="line">nameItem.displayName = <span class="string">@"姓名"</span>;</span><br><span class="line">nameItem.validationType = ValidationTypeRequired | ValidationTypeChinese;</span><br><span class="line"></span><br><span class="line">TextFieldFormItem *idCardItem = [TextFieldFormItem new];</span><br><span class="line">idCardItem.name = <span class="string">@"idCard"</span>;</span><br><span class="line">idCardItem.placeholder = <span class="string">@"与身份证号码一致"</span>;</span><br><span class="line">idCardItem.displayName = <span class="string">@"身份证号"</span>;</span><br><span class="line">idCardItem.validationType = ValidationTypeRequired | ValidationTypeIdcard;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数据源</span></span><br><span class="line">_form.formItems = @[nameItem, idCardItem, ...];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义合规信号</span></span><br><span class="line"><span class="keyword">self</span>.validSignal = [RACSignal combineLatest:itemValidSignalArray reduce:^<span class="keyword">id</span>&#123;</span><br><span class="line"><span class="keyword">return</span> @([<span class="keyword">self</span>.form validate]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义提交动作，当合规信号发送YES时可用。</span></span><br><span class="line"><span class="keyword">self</span>.submitCommand = [[RACCommand alloc] initWithEnabled:<span class="keyword">self</span>.validSignal signalBlock:^RACSignal *(<span class="keyword">id</span> input)&#123;</span><br><span class="line"><span class="comment">// 调用REST API，并返回此网络请求的信号</span></span><br><span class="line"><span class="keyword">return</span> [APIClient saveBaseInfo:[<span class="keyword">self</span>.form dicValue]];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ViewController里将ViewModel进行绑定。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loadView &#123;</span><br><span class="line">[<span class="keyword">super</span> loadView];</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize view;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.infoVM = [InfoViewModel new];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.nextBtn.rac_command = <span class="keyword">self</span>.infoVM.submitCommand;</span><br><span class="line">RAC(<span class="keyword">self</span>.nextBtn, backgroundColor) = [<span class="keyword">self</span>.infoVM.validSignal map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line"><span class="keyword">return</span> [value boolValue] ? KKThemeGreenColor : KKGrayBackgroundColor;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅提交动作的结果</span></span><br><span class="line">[<span class="keyword">self</span>.infoVM.submitCommand.executeSignals.switchToLatest subscribeNext:^(<span class="keyword">id</span> x)&#123;</span><br><span class="line"><span class="comment">// submit successful, nav to next VC</span></span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，例子就基本已经完成了，可以看到整个结构及之间的关系很清晰。ViewController和ViewModel之间进行绑定，ViewModel负责业务逻辑相关的处理，而ViewController则只单一的负责UI的交互与呈现。UI的变化都自动的从ViewModel中的属性值变化而来。Cell与子ViewModel之间也同样的进行绑定，所有的业务逻辑中的值变化，都会自动的反应到UI上的变化。并且所有相关的ViewModel关联的入口都相对的非常集中并且单一，在初始化时绑定好ViewModel，接下来的事情就只需要思考在ViewModel中怎么样去进行业务逻辑的处理了。</p><p>详细的Demo稍候奉上。</p><p>##参考资料</p><ul><li><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa Github</a></li><li><a href="http://www.cocoachina.com/ios/20150526/11930.html" target="_blank" rel="noopener">ReactiveCocoa 和 MVVM 入门</a></li><li><a href="http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1" target="_blank" rel="noopener">MVVM Tutorial with ReactiveCocoa: Part 1/2</a></li><li><a href="http://limboy.me/ios/2013/12/27/reactivecocoa-2.html" target="_blank" rel="noopener">说说ReactiveCocoa 2</a></li><li><a href="http://limboy.me/ios/2014/06/06/deep-into-reactivecocoa2.html" target="_blank" rel="noopener">ReactiveCocoa2实战</a></li><li><a href="http://www.jianshu.com/p/87ef6720a096" target="_blank" rel="noopener">ReactiveCocoa之基础篇</a></li><li><a href="http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-1.html" target="_blank" rel="noopener">细说ReactiveCocoa的冷信号与热信号（一）</a></li><li>几个不错的MVVM＋ReactiveCocoa实例:<ul><li><a href="https://github.com/ashfurrow/FunctionalReactivePixels" target="_blank" rel="noopener">FunctionalReactivePixels</a></li><li><a href="https://github.com/leichunfeng/MVVMReactiveCocoa" target="_blank" rel="noopener">MVVMReactiveCocoa</a></li><li><a href="https://github.com/sprynmr/sprynthesis-samples" target="_blank" rel="noopener">ReactiveCocoa 和 MVVM 入门的Demo</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MVVM&quot;&gt;&lt;a href=&quot;#MVVM&quot; class=&quot;headerlink&quot; title=&quot;MVVM&quot;&gt;&lt;/a&gt;MVVM&lt;/h2&gt;&lt;p&gt;传统MVC模式下的iOS开发存在一些问题， ViewController过分臃肿，处理业务逻辑、发送网络请求、响应UI交互、读取持久化数据。为了给ViewController瘦身，通常都会尽量的抽取能够复用的东西单独作为一个模块。尽管如此，ViewController仍然是一个庞大的家伙。&lt;/p&gt;
&lt;p&gt;MVVM可以说是MVC的一个延伸，对于应用程序的结构有了更清晰的划分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Model: 仍然同MVC的M，作为实体模型。&lt;/li&gt;
&lt;li&gt;View: 包含视图本身，以及UI交互的处理。UIView及相关的xib/storyboard自然属于这一概念之内，而ViewController事实上也属于这一层，它仅处理和视图、UI相关的逻辑。&lt;/li&gt;
&lt;li&gt;View-Model: 处理原来ViewController留下的一大堆烂摊子，从必要的资源（数据库、网络）中获取原始数据，处理业务逻辑，并将数据通过属性暴露给ViewController，这部分数据仅仅是与视图显示相关的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结一下：原来的ViewController中与UI无关的部分，挪到了ViewModel中，由ViewModel来负责给View层提供View所需要的数据，ViewController则负责和UI相关的交互处理。&lt;/p&gt;
&lt;p&gt;在这样架构下的App逻辑里，当ViewModel中的数据发生改变时，我们自然而然的期望视图中相关的UI也发生改变；当我们在输入框中输入文字时，我们也同样期望ViewModel中相关的数据发生改变。&lt;/p&gt;
&lt;p&gt;在我们已知的技术手段里，可以通过写一系列的事件回调(&lt;code&gt;Delegate&lt;/code&gt;)、通知处理(&lt;code&gt;Notification&lt;/code&gt;)、观察者(&lt;code&gt;KVO&lt;/code&gt;)来实现上述目标。当然代价是我们需要小心谨慎的在合适的地方维护好这些实现方法，比如，处理好&lt;code&gt;observer&lt;/code&gt;应该在何时被移除，检查是否监听了对的&lt;code&gt;notification name&lt;/code&gt;。总而言之，这并不是一件轻松的事儿，它需要有一个非常成熟的整体架构来支持，不然的话可能到处是掉进去出不来的坑。&lt;/p&gt;
&lt;p&gt;ReactiveCocoa可以很好的帮助我们在iOS中实现MVVM这一模式，当然在iOS里实现这一模式，并不是一定需要ReactiveCocoa，但是它绝对能帮助我们节省很多时间。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>轻量级ViewController的实践</title>
    <link href="http://yiyangest.github.io/2015/08/05/lighter-view-controller-practice/"/>
    <id>http://yiyangest.github.io/2015/08/05/lighter-view-controller-practice/</id>
    <published>2015-08-04T16:00:00.000Z</published>
    <updated>2018-02-27T10:06:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="废话太多的前言"><a href="#废话太多的前言" class="headerlink" title="废话太多的前言"></a>废话太多的前言</h2><p>在大多数情况下，ViewController都是我们代码中的重点，贯穿开发过程的始终。ViewController作为我们通常所理解的<code>MVC</code>模式中的<code>C</code>部分，承载了太多的责任和内容。</p><blockquote><p>ViewController是View和Model之间的纽带，它将Model背后所代表的业务知识转化成View所能理解的语言。当然iOS中的ViewController工作不仅限于此，它还包括：管理自己的生命周期，负责生成并管理自己的所有view实例，监听并处理来自View和业务相关的事件通知等等。</p></blockquote><a id="more"></a><p>我们再对比看看View和Model所负责的事情：</p><ul><li>View: 毫无争议的只负责呈现UI相关的内容，同时包括产生一些事件，如点击或者触摸。</li><li>Model: 建立业务模型，给冷冰冰的数字赋予生命。关于Model还有一些争议，就是这些模型数据的存储与处理，是否应当属于Model的职责范围，这个问题只能说见仁见智吧，没有标准答案。</li></ul><p>相较之下，毫无疑问，ViewController绝对是重量级选手，View和Model都有相对比较独立的关注点，而ViewController则要为他们二者之间的交流问题操碎了心。于是我们会很容易得看到随着产品的迭代，需求的增长，ViewController也变得越来越臃肿。</p><p>我刚刚开始接触iOS开发的那段时间，兴高采烈的将公司iOS app的源代码checkout到本地，找到用户登录后第一个展现的FeedViewController, 2000多行，瞬间读下去的欲望降低50%。</p><p>当然从一开始的时候，人们就会从架构上为ViewController减轻负担，分离出网络请求层，分离出数据存储层等等。除开这些常见的模式之外呢，还有什么手段能够为ViewController瘦身？</p><p><a href="http://www.objc.io/issues/1-view-controllers/lighter-view-controllers/" target="_blank" rel="noopener">objc.io第一期</a>就围绕这个话题展开，主要是将TableViewDataSource封装成一个单独的对象，来达到给ViewController瘦身的目的，当然文中还提到了一些其他的方法，不过并不在本文的讨论范围之内。本文主要讲述针对含有TableView的VC的瘦身实践。实践必然会有成果，成果在<a href="https://github.com/yiyangest/KKTableView" target="_blank" rel="noopener">这里</a>，如果觉得有用的话，也是可以通过</p><pre><code>pod &apos;KKTableView&apos;, :git=&gt;&apos;https://github.com/yiyangest/KKTableView.git&apos;</code></pre><p>的方式来加入到你的工程之中（目前还没有将KKTableView注册到CocoaPods的公共库中，所以暂时用<code>:git=&gt;</code>的方式来集成）。</p><h2 id="千篇一律的UITableViewDataSource"><a href="#千篇一律的UITableViewDataSource" class="headerlink" title="千篇一律的UITableViewDataSource"></a>千篇一律的UITableViewDataSource</h2><p>UITableView有两个重要的protocol: <code>UITableViewDataSource</code>和<code>UITableViewDelegate</code>, 一个负责提供tableView所需的数据模型, 一个负责tableView可视化上的定制效果。一般来说delegate每个VC需要实现的内容都不一样，VC究竟会实现其中的哪几个方法也是不确定的，因此对delegate进行抽象的话，个人感觉意义不是很大。</p><p>而dataSource，有两个必须实现的方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section;</span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</span><br></pre></td></tr></table></figure><p>一共有多少行，每一行的cell是什么样的。</p><p>在绝大多数的VC里面，我们会看到类似这样的代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.dataArray.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line"><span class="built_in">UITableViewCell</span> * cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@"cellIdentifier"</span>];</span><br><span class="line">Model * item = <span class="keyword">self</span>.dataArray[indexPath.row];</span><br><span class="line"><span class="comment">// 用item去配置cell</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一会不同的，可能就是用item去配置cell这部分了。可以很明显的看出所有的UITableViewDataSource其实就是在围绕dataArray(也就是你的结果集)做文章，何不把这部分代码挪到单独的代码里去呢。</p><p>于是很自然的抽象出一个对象，遵循UITableViewDataSource，实现其方法，并在此基础上封装便利的公共方法。</p><p>KKTableViewDataSource便是这样一个对象，基本的思路和实现方式是参照上面提到的那篇<a href="http://objc.io" target="_blank" rel="noopener">objc.io</a>上的<a href="http://www.objc.io/issues/1-view-controllers/table-views/" target="_blank" rel="noopener">文章</a>。</p><p>下面说说不一样的地方，那篇文章里所实现的dataSource只能处理单一类型cell的情况。一般来说，不同种类的cell会具有不同的identifier。而那篇文章里所实现的dataSource只能持有一个identifier。当然人家这只是写个Demo，重在阐述分离UITableViewDataSource的思想。所以剩下的工作当然是要靠我们自己去实践的。</p><p>UITableView提供了这么一套流程:</p><p>首先：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)registerClass:(Class)cellClass forCellReuseIdentifier:(<span class="built_in">NSString</span> *)identifier;</span><br></pre></td></tr></table></figure><p>注册cell的class到对应的identifier上（当然也可以在storyboard中填写该属性），之后你可以放心大胆的使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)dequeueReusableCellWithIdentifier:(<span class="built_in">NSString</span> *)identifier;</span><br></pre></td></tr></table></figure><p>根据不同的identifier返回对应的cell。</p><p>于是我们给抽象出来的dataSource加上一个cellIdentifier数组，在配置数据源时，我们将所有的cellIdentifier传给dataSource，然后dataSource在<code>cellForRowAtIndexPath</code>中根据不同的identifier返回对应的cell。</p><p>接下来的问题在于如何处理identifier和indexPath之间的关系。其实identifier并不是和indexPath之间具有某种联系，它是和indexPath背后的item具有某种联系。通常，在item中会有某个属性（比如type）来决定它对应的cell是哪一种cell。于是问题就演化为如何让我们的dataSource知道item与identifier之间的关系。这种关系是与业务紧密相联的，于是只提供一个block，让业务端去表现这种联系。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Class(^CellClassConfigureBlock)(<span class="keyword">id</span> item);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KKTableViewDataSource</span> : <span class="title">NSObject</span>&lt;<span class="title">UITableViewDataSource</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) CellClassConfigureBlock cellClassConfigureBlock;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在VC中设置block，大概会是像这个样子：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.dataSource.cellClassConfigureBlock = ^(Person *model) &#123;</span><br><span class="line"><span class="keyword">if</span> (model.userno % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> [RightCell <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> [PersonCell <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这个block返回的是Class，这里我遵循了cell的identifier与className保持一致的约定。所以返回的是cell的Class还是直接是字符串类型的identifier都是一样的。<code>KKBaseCell</code>的<code>cellReuseIdentifier</code>类方法也就是做了这么一件事。当然可能这里返回一个<code>Class</code>会让人觉得很别扭，在后续的过程中，我会考虑将这里的返回值改为<code>NSString</code>。</p><p>有了这些基础之后，我们就可以很容易的拿到正确的cell了，利用自己封装的结果集，我们也能够很容易的拿到正确的model，接下来的事情就是如何用model去配置cell。一般而言，这个配置的过程会封装在cell类当中，简单考虑，我们可以在cell的基类当中定义一个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)configureCellWithModel:(<span class="keyword">id</span>)model;</span><br></pre></td></tr></table></figure><p>然后在各个子类当中去实现它。这样我们将model与cell之间的关系就简化了，甚至在我们抽象的dataSource中只要调用 <code>[cell configureCellWithModel:model]</code>就行了。外部的VC都完全不需要进行配置。</p><p>理想是美好的，然而在实践过程中，还是有许多的意外。有一部分业务会导致cell与VC之间产生交互。一般会通过delegate或者block的形式来实现这一目标。所以还是需要业务方介入来对cell进行更为灵活的配置，在VC里给cell设置相应的delegate或者block。可以通过给dataSource设置一个<code>configureBlock</code>来实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^CellConfigureBlock)(<span class="keyword">id</span> cell, <span class="keyword">id</span> item);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) CellConfigureBlock configureBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ViewController里设置cell的配置块</span></span><br><span class="line"><span class="keyword">self</span>.dataSource.configureBlock = ^(ShopListCell *cell, ShopModel *item) &#123;</span><br><span class="line">    [cell configureWithModel:item telClickBlock:block1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果不同种的cell有不同的配置需求，也就是对应不同的配置块，那么可以通过：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)registerConfigureBlock:(CellConfigureBlock)block forCellClassName:(<span class="built_in">NSString</span> *)className;</span><br></pre></td></tr></table></figure><p>来给不同的cell注册不同的配置块。</p><p>KKTableViewDataSource除了解决以上问题以外，还封装了一些常用的便利的方法，这些方法也是继承KKTableViewDataSource时需要考虑是否重写的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 增、删数据源数组</span></span><br><span class="line">- (<span class="keyword">void</span>)addItem:(<span class="keyword">id</span>)item;</span><br><span class="line">- (<span class="keyword">void</span>)addItemsArray:(<span class="built_in">NSArray</span> *)items;</span><br><span class="line">- (<span class="keyword">void</span>)clearItems;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 只读类方法</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)cellIdentifierForIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</span><br><span class="line">- (CellConfigureBlock)cellConfigureBlockForIdentifier:(<span class="built_in">NSString</span> *)identifier;</span><br><span class="line">- (<span class="keyword">id</span>)itemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)items;</span><br></pre></td></tr></table></figure><p>KKTableViewDataSource将结果集对象隐藏在背后，因此当你的结果集需要从一个普通的NSMutableArray变换为CoreData或者其他的实现时，是很容易进行更改的。只需要继承KKTableViewDataSource，实现你的结果集就可以了，而业务方也就是ViewController里面不需要做什么更改。</p><h2 id="包含TableView的ViewController"><a href="#包含TableView的ViewController" class="headerlink" title="包含TableView的ViewController"></a>包含TableView的ViewController</h2><p>仅仅有了一个封装后的dataSource还不够，我们再回过头来看看列表类的ViewController里面所包含的东西。一个UITableView，这是必须的。绝大多数的这种ViewController里面还会含有下拉刷新和上拉加载更多的控件，以及一个分页模型。</p><p>不如把这些东西都打包进一个基类里面，<code>KKTableViewController</code>就是这么一个基类，里面有分页模型，有tableView，也有我们上面提到的dataSource。tableView自动拥有下拉刷新和上拉更多的特性，子类只需要实现<code>refresh</code>和<code>loadMore</code>这两个方法。其他需要子类实现的方法有:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)configureTableView;</span><br></pre></td></tr></table></figure><p>该方法需要实现tableVieww对cellClass的注册，其他的比如tableView的背景颜色，分割线样式等也可以在这里进行设置。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)configureDataSource;</span><br></pre></td></tr></table></figure><p>该方法需要实现dataSource的cellIdentifier和configureBlock的设置。</p><p>别忘了在<code>viewDidLoad</code>中将父类的<code>tableView</code>加到<code>self.view</code>中。</p><h2 id="已经是某个BaseViewController的子类"><a href="#已经是某个BaseViewController的子类" class="headerlink" title="已经是某个BaseViewController的子类"></a>已经是某个BaseViewController的子类</h2><p>如果是项目的基本架构早已经搭建完毕，甚至开发已经进行了一部分了，通常来说项目当中会有一个BaseViewController，其他的VC都从这派生而来。这时候你会发现上面提到的<code>KKTableViewController</code>并没有什么卵用。让BaseViewController从<code>KKTableViewController</code>继承不太现实，毕竟不是所有的ViewController都是有tableView的。</p><p>没有多继承，protocol只能定义一堆空空的接口（绝对没有贬低protocol的意思，protocol大有用处，只不过在这里对我们封装ViewController并没有太大的帮助）。那么工作只能交给Category了。</p><p><code>UIViewController+KKTableView</code>提供了上面所说<code>KKTableViewController</code>中绝大多数功能。但也需要protocol的帮助，将ViewController需要自己配合实现的方法放在了<code>KKTableViewControllerDelegate</code>这个protocol中，业务方按需实现。</p><p>在实现过程中，并没有选择使用swizzling的方式去侵入ViewController的生命周期来实现自动初始化tableView和dataSource及相关配置。因为swizzling通常会放在<code>+load</code>中执行，并且影响整个应用级别的类行为，而我们这里并不希望所有的ViewController都莫名其妙多一个tableView。</p><p>所以还是需要在ViewController里合适的位置，调用一下<code>[self kk_loadView]</code>来执行tableView和dataSource的初始化及基本配置。剩下要做的事情就跟KKTableViewController比较类似了。</p><h2 id="TableView的自动算高"><a href="#TableView的自动算高" class="headerlink" title="TableView的自动算高"></a>TableView的自动算高</h2><p>在TableView的实践里，还有一件事情在大多数情况下会去做，就是实现<code>UITableViewDelegate</code>中的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</span><br></pre></td></tr></table></figure><p>没错，就是计算每一行的高度。</p><p>在<code>KKTableViewController</code>和<code>UIViewController+KKTableView</code>中都实现了这个方法，并且能够适应大多数情况。这里的大多数情况指采用autolayout的方式设置cell里的子view位置，并且约束设置合理，能够撑得起来cell的contentView。</p><p>实现的思路和方式是参考的<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener">UITableView-FDTemplateLayoutCell</a>，不过并没有完全把它的代码引用过来，并没有实现它里面描述的利用Runloop预计算每一行的高度，也没有实现对frame layout的支持。相对的，<code>UITableView+KKLayoutCell</code>利用了<code>KKTableViewDataSource</code>中的一些方法来实现对高度的计算。会在今后的进一步实践后，考虑是否有必要引入<code>UITableView-FDTemplateLayoutCell</code>的预计算和支持frame layout的特性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面写了好长一篇的废话，主要介绍了在参考<a href="http://www.objc.io/issues/1-view-controllers/lighter-view-controllers/" target="_blank" rel="noopener">这篇文章</a>后所做的一些实践，以及实践的<a href="https://github.com/yiyangest/KKTableView" target="_blank" rel="noopener">成果</a>。在目前的工作中已经开始使用这个成果了，会进一步的结合工作及实践情况，对<a href="https://github.com/yiyangest/KKTableView" target="_blank" rel="noopener">KKTableView</a>进行不断完善和改进。</p><p>最后总结一句：</p><blockquote><p>懒是推动人类进步的动力。</p></blockquote><p>因为懒，大家总结出各种各样的模式与框架，催生出了优秀的开源项目以及各式科技发明。可怕的不是懒，而是失掉了一颗积极进取的心。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;废话太多的前言&quot;&gt;&lt;a href=&quot;#废话太多的前言&quot; class=&quot;headerlink&quot; title=&quot;废话太多的前言&quot;&gt;&lt;/a&gt;废话太多的前言&lt;/h2&gt;&lt;p&gt;在大多数情况下，ViewController都是我们代码中的重点，贯穿开发过程的始终。ViewController作为我们通常所理解的&lt;code&gt;MVC&lt;/code&gt;模式中的&lt;code&gt;C&lt;/code&gt;部分，承载了太多的责任和内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ViewController是View和Model之间的纽带，它将Model背后所代表的业务知识转化成View所能理解的语言。当然iOS中的ViewController工作不仅限于此，它还包括：管理自己的生命周期，负责生成并管理自己的所有view实例，监听并处理来自View和业务相关的事件通知等等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
