<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 当Swift的泛型继承遇见NSObject · 深谷</title><meta name="description" content="本文主要记录了在Swift的泛型继承时如果有NSObject，会产生内存异常EXC_BAD_ACCESS的问题。"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/yiyangest" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">当Swift的泛型继承遇见NSObject</h1><div class="post-time">2016年6月17日</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是在一个项目里遇到的坑，不过能出现的条件还是比较特别的，可能在大多数项目当中并不会出现。在此还是记录一下。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一个泛型基类，假设有子类继承此基类，并在子类的泛型约束中指定类型必须是<code>NSObject</code>的子类。如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseA</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(whenSuccess successHandler: T?-&gt;Void)</span></span> &#123;</span><br><span class="line">        <span class="comment">//Do something and when success call successHandler(result)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildB</span>&lt;<span class="title">T</span>:<span class="title">NSObject</span>&gt;: <span class="title">BaseA</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(whenSuccess successHandler: T?-&gt;Void)</span></span> &#123;</span><br><span class="line">        <span class="comment">//Do something and when success call successHandler(result)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你实例化一个子类对象，并调用子类对象的<code>execute</code>方法，那么恭喜你，你就中招了。比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="type">ChildB</span>&lt;<span class="type">NSString</span>&gt;()</span><br><span class="line">b.execute()&#123;</span><br><span class="line">    result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"ChildB result: \(result)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行，程序很快挂掉，并为你指出发生了一个<code>EXC_BAD_ACCESS</code>的错误。</p>
<a id="more"></a>
<p>为了证明这个是<code>NSObject</code>的锅，我们可以再定义一个子类，这个子类的泛型约束中不再指定类型必须是<code>NSObject</code>的子类。如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildC</span>&lt;<span class="title">T</span>:<span class="title">Any</span>&gt;: <span class="title">BaseA</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(whenSuccess successHandler: T?-&gt;Void)</span></span> &#123;</span><br><span class="line">        <span class="comment">//Do something and when success call successHandler(result)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="type">ChildC</span>&lt;<span class="type">NSString</span>&gt;()</span><br><span class="line"><span class="built_in">c</span>.execute()&#123;</span><br><span class="line">    result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"ChildC result: \(result)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行，ChildC对象执行过程中并没有报错。</p>
<p>这个内存异常和继承有关系吗？我们可以再试试，定义一个泛型类，不继承任何类，只是在约束中指定类型必须是<code>NSObject</code>的子类。如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseB</span>&lt;<span class="title">T</span>:<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(whenSuccess successHandler: T?-&gt;Void)</span></span> &#123;</span><br><span class="line">        <span class="comment">//Do something and when success call successHandler(result)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baseB = <span class="type">BaseB</span>&lt;<span class="type">NSString</span>&gt;()</span><br><span class="line">baseB.execute()&#123;</span><br><span class="line">    result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"BaseB result: \(result)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后，BaseB对象执行过程中并没有报错。BaseB与ChildB的唯一区别就是ChildB有继承关系。</p>
<p>我们可以再试着改写一下，定义一个子类，这个子类的泛型约束同ChildB一样，但是不再重写父类中的execute方法。如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildD</span>&lt;<span class="title">T</span>:<span class="title">NSObject</span>&gt;: <span class="title">BaseA</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// no more override func execute()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="type">ChildD</span>&lt;<span class="type">NSString</span>&gt;()</span><br><span class="line">d.execute()&#123;</span><br><span class="line">    result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"ChildD result: \(result)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后，多年的<code>EXC_BAD_ACCESS</code>病也治好了！</p>
<p>可以总结归纳一下，出现这种情况的<code>EXC_BAD_ACCESS</code>必须满足以下几个条件：</p>
<ul>
<li>子类中的泛型约束必须指定为<code>NSObject</code>的子类；</li>
<li>子类必须重写父类中的方法；</li>
<li>重写的方法中，必须有闭包引用泛型，例如：<code>T?-&gt;Void</code>；</li>
</ul>
<p>应该来说还是比较难出现这种情况的。碰巧被我赶上了…</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>这里可以介绍一下场景，场景是一个很常见的场景，但是在作代码架构设计的时候不小心搞出了这个妖蛾子。</p>
<p>在Swift中解析JSON并转为相应的Model，常用的库有<a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="noopener">ObjectMapper</a>，<a href="https://github.com/thoughtbot/Argo" target="_blank" rel="noopener">Argo</a>等，不过这些库都有一个问题，就是必须手动的将模型的属性和JSON字串里的key一一对应。当然这并不能赖这些库不好，而是Swift里的类并不具备OC运行时的特性（除非加了<code>@objc</code>关键字)，而目前Swift里的反射还非常的弱，只能读取类属性和类的值，并不能利用反射为类属性赋值。手写代码一一对应并不是什么难事，可问题是程序员都是懒的，碰见一个二十多甚至更多属性的类，顿时就不想再这么手写下去了。OC时代早就不这么手写代码对应了，于是只好想了一个办法，将OC的模型映射库(比如<a href="https://github.com/ibireme/YYModel" target="_blank" rel="noopener">YYModel</a>)作一个桥接，让Swift代码也可以调用这个库。问题在于YYModel这类OC的映射库都是利用了OC的运行时机制，因此Swift类想要用YYModel，就只能继承于<code>NSObject</code>，让它也具有运行时的特性。<br>于是设计了一个模型基类继承于<code>NSObject</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span>: <span class="title">NSObject</span>, <span class="title">NSCoding</span> </span>&#123;</span><br><span class="line">    <span class="comment">// properties</span></span><br><span class="line">    <span class="comment">// methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>网络部分利用<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a>去请求API，并将返回的JSON解析为对应的Model。为此封装了一下<code>Alamofire</code>作为网络请求的底层：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkEngine</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... other network methods</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doPost</span>&lt;T: NSObject&gt;<span class="params">(url: String, byParams params: [String: AnyObject], whenSuccess successHandler: T? -&gt; Void, whenError errorHandler: ErrorHandler?)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//... other network methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外设计了一个网络API类，负责接收网络API的URL及请求参数，并对请求参数作加密等处理，内部调用封装好的<code>NetworkEngine</code>去发起请求，并将解析完的Model结果通过闭包返回给上层。<br>因为有些网络请求回来的结果需要映射到一个Model上，而也有小部分网络请求回来的结果并不需要映射到Model上，比如仅仅是一个<code>true</code>或者<code>false</code>，为此也创建Model似乎不太值当。于是设计了两种处理不同类型的网络API子类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseAPI</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// properties</span></span><br><span class="line">    <span class="comment">// other methods</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(whenSuccess successHandler: T?-&gt;Void, whenError: ErrorHandler?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// call NetworkEngine.doPost() and when success call successHandler to return T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelAPI</span>&lt;<span class="title">T</span>:<span class="title">BaseModel</span>&gt;: <span class="title">BaseAPI</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(whenSuccess successHandler: T?-&gt;Void, whenError: ErrorHandler?)</span></span> &#123;</span><br><span class="line">        networkEngine.doPost(url, byParams: params, whenSuccess: successHandler, whenError: whenError)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DictAPI</span>: <span class="title">BaseAPI</span>&lt;[<span class="title">String</span>: <span class="title">AnyObject</span>]&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(whenSuccess successHandler: [String: AnyObject]?-&gt;Void, whenError: ErrorHandler?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// call NetworkEngine.doPost() and when success call successHandler to return [String: AnyObject]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是在上层实例化<code>ModelAPI</code>对象时，就悲剧了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> loginAPI = <span class="type">ModelAPI</span>&lt;<span class="type">Account</span>&gt;(url: <span class="string">""</span>, params: [<span class="string">"..."</span>: <span class="string">"..."</span>])</span><br><span class="line">loginAPI.execute(whenSuccess: &#123;</span><br><span class="line">    user <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// handle logined user</span></span><br><span class="line">    <span class="comment">// crashed and point EXC_BAD_ACCESS problem.</span></span><br><span class="line">    &#125;, whenError: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>于是乎只好重新设计一下网络层，绕过这个坑。</p>
<h2 id="内幕"><a href="#内幕" class="headerlink" title="内幕(?)"></a>内幕(?)</h2><p>没有内幕。。。</p>
<p>好吧，虽然调试找原因花了很长的时间才定位到是继承重写泛型类闹的，但是依然没有找到这一过程的内幕究竟发生了些什么导致内存异常的。大致的推断可能是Swift兼容OC的一个Bug。。。（什么鬼，裤子都脱了给我看这个…）<br>可能涉及的点有：</p>
<ul>
<li><p>Swift的运行时机制是和OC完全不同的一套，OC采用消息转发、动态派发等方式来在运行时动态决定实际调用的实现。而Swift采用了一套类似于C++里的虚拟函数表(<code>vtable</code>)的机制，在编译时就确定调用方法的实现。</p>
</li>
<li><p>继承于<code>NSObject</code>的类，编译器会隐式的给其属性自动加上<code>@objc</code>的注解，使其具有OC运行时的特性。</p>
</li>
<li><p>闭包类似于OC中的block，闭包会隐式的持有内部用到的外部变量的强引用。</p>
</li>
</ul>
<p>暂时就这么多了。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/04/22/building-the-f8-2016-app/" class="next">下一篇</a></div><div data-thread-key="2016/06/17/when-swift-generic-inheritance-meets-nsobject/" data-title="当Swift的泛型继承遇见NSObject" data-url="http://yiyangest.github.io/2016/06/17/when-swift-generic-inheritance-meets-nsobject/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"yiyangest"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 - 2018 <a href="http://yiyangest.github.io">yiyangest</a>, unless otherwise noted.</p></div></footer></div><script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>